//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_dcache.v
// Title            : Data cache
// Dependencies     : lm32_include.v
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : Support for user-selected resource usage when implementing
//                  : cache memory. Additional parameters must be defined when
//                  : invoking lm32_ram.v
// =============================================================================

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types







/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_dcache (
    // ----- Inputs -----
    clk_i,
    rst_i,
    stall_a,
    stall_x,
    stall_m,
    address_x,
    address_m,
    load_q_m,
    store_q_m,
    store_data,
    store_byte_select,
    refill_ready,
    refill_data,
    dflush,
    dtlb_miss_x,
    // ----- Outputs -----
    stall_request,
    restart_request,
    refill_request,
    refill_address,
    refilling,
    load_data
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter associativity = 1;                            // Associativity of the cache (Number of ways)
parameter sets = 512;                                   // Number of sets
parameter bytes_per_line = 16;                          // Number of bytes per cache line
parameter base_address = 0;                             // Base address of cachable memory
parameter limit = 0;                                    // Limit (highest address) of cachable memory

localparam addr_offset_width = $clog2-2;
localparam addr_set_width = $clog2;
localparam addr_offset_lsb = 2;
localparam addr_offset_msb = (addr_offset_lsb+addr_offset_width-1);
localparam addr_set_lsb = (addr_offset_msb+1);
localparam addr_set_msb = (addr_set_lsb+addr_set_width-1);
localparam addr_tag_lsb = (addr_offset_msb+1);
localparam addr_tag_msb = $clog2;
localparam addr_tag_width = (addr_tag_msb-addr_tag_lsb+1);

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                                            // Clock
input rst_i;                                            // Reset

input stall_a;                                          // Stall A stage
input stall_x;                                          // Stall X stage
input stall_m;                                          // Stall M stage

input [(32-1):0] address_x;                       // X stage load/store address
input [(32-1):0] address_m;                       // M stage load/store address
input load_q_m;                                         // Load instruction in M stage
input store_q_m;                                        // Store instruction in M stage
input [(32-1):0] store_data;                      // Data to store
input [(4-1):0] store_byte_select;        // Which bytes in store data should be modified

input refill_ready;                                     // Indicates next word of refill data is ready
input [(32-1):0] refill_data;                     // Refill data

input dflush;                                           // Indicates cache should be flushed

input dtlb_miss_x;                                      // Indicates if a DTLB miss has occured

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output stall_request;                                   // Request pipeline be stalled because cache is busy
wire   stall_request;
output restart_request;                                 // Request to restart instruction that caused the cache miss
reg    restart_request;
output refill_request;                                  // Request a refill
reg    refill_request;
output [(32-1):0] refill_address;                 // Address to refill from
reg    [(32-1):0] refill_address;
output refilling;                                       // Indicates if the cache is currently refilling
reg    refilling;
output [(32-1):0] load_data;                      // Data read from cache
wire   [(32-1):0] load_data;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

wire read_port_enable;                                  // Cache memory read port clock enable
wire write_port_enable;                                 // Cache memory write port clock enable
wire [0:associativity-1] way_tmem_we;                   // Tag memory write enable
wire [0:associativity-1] way_dmem_we;                   // Data memory write enable
wire [(32-1):0] way_data[0:associativity-1];      // Data read from data memory
wire [((addr_tag_width+1)-1):1] way_tag[0:associativity-1];// Tag read from tag memory
wire [0:associativity-1] way_valid;                     // Indicates which ways are valid
wire [0:associativity-1] way_match;                     // Indicates which ways matched
wire miss;                                              // Indicates no ways matched

wire [(addr_set_width-1):0] tmem_read_address;        // Tag memory read address
wire [(addr_set_width-1):0] tmem_write_address;       // Tag memory write address
wire [((addr_offset_width+addr_set_width)-1):0] dmem_read_address;        // Data memory read address
wire [((addr_offset_width+addr_set_width)-1):0] dmem_write_address;       // Data memory write address
wire [((addr_tag_width+1)-1):0] tmem_write_data;               // Tag memory write data
reg [(32-1):0] dmem_write_data;                   // Data memory write data

reg [2:0] state;                         // Current state of FSM
wire flushing;                                          // Indicates if cache is currently flushing
wire check;                                             // Indicates if cache is currently checking for hits/misses
wire refill;                                            // Indicates if cache is currently refilling

wire valid_store;                                       // Indicates if there is a valid store instruction
reg [associativity-1:0] refill_way_select;              // Which way should be refilled
reg [addr_offset_msb:addr_offset_lsb] refill_offset;           // Which word in cache line should be refilled
wire last_refill;                                       // Indicates when on last cycle of cache refill
reg [(addr_set_width-1):0] flush_set;                 // Which set is currently being flushed

genvar i, j;

/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Instantiations
/////////////////////////////////////////////////////

   generate
      for (i = 0; i < associativity; i = i + 1)
        begin : memories
           // Way data
           if ((addr_offset_width+addr_set_width) < 11)
             begin : data_memories
                lm32_ram
                  #(
                    // ----- Parameters -------
                    .data_width (32),
                    .address_width ((addr_offset_width+addr_set_width))
// Modified for Milkymist: removed non-portable RAM parameters
                    ) way_0_data_ram
                    (
                     // ----- Inputs -------
                     .read_clk (clk_i),
                     .write_clk (clk_i),
                     .reset (rst_i),
                     .read_address (dmem_read_address),
                     .enable_read (read_port_enable),
                     .write_address (dmem_write_address),
                     .enable_write (write_port_enable),
                     .write_enable (way_dmem_we[i]),
                     .write_data (dmem_write_data),
                     // ----- Outputs -------
                     .read_data (way_data[i])
                     );
             end
           else
             begin
                for (j = 0; j < 4; j = j + 1)
                  begin : byte_memories
                     lm32_ram
                       #(
                         // ----- Parameters -------
                         .data_width (8),
                         .address_width ((addr_offset_width+addr_set_width))
// Modified for Milkymist: removed non-portable RAM parameters
                         ) way_0_data_ram
                         (
                          // ----- Inputs -------
                          .read_clk (clk_i),
                          .write_clk (clk_i),
                          .reset (rst_i),
                          .read_address (dmem_read_address),
                          .enable_read (read_port_enable),
                          .write_address (dmem_write_address),
                          .enable_write (write_port_enable),
                          .write_enable (way_dmem_we[i] & (store_byte_select[j] | refill)),
                          .write_data (dmem_write_data[(j+1)*8-1:j*8]),
                          // ----- Outputs -------
                          .read_data (way_data[i][(j+1)*8-1:j*8])
                          );
                  end
             end

           // Way tags
           lm32_ram
             #(
               // ----- Parameters -------
               .data_width ((addr_tag_width+1)),
               .address_width (addr_set_width)
// Modified for Milkymist: removed non-portable RAM parameters
               ) way_0_tag_ram
               (
                // ----- Inputs -------
                .read_clk (clk_i),
                .write_clk (clk_i),
                .reset (rst_i),
                .read_address (tmem_read_address),
                .enable_read (read_port_enable),
                .write_address (tmem_write_address),
                .enable_write (1'b1),
                .write_enable (way_tmem_we[i]),
                .write_data (tmem_write_data),
                // ----- Outputs -------
                .read_data ({way_tag[i], way_valid[i]})
                );
        end

   endgenerate

/////////////////////////////////////////////////////
// Combinational logic
/////////////////////////////////////////////////////

// Compute which ways in the cache match the address being read
generate
    for (i = 0; i < associativity; i = i + 1)
    begin : match
assign way_match[i] = ({way_tag[i], way_valid[i]} == {address_m[addr_tag_msb:addr_tag_lsb], 1'b1});
    end
endgenerate

// Select data from way that matched the address being read
generate
    if (associativity == 1)
         begin : data_1
assign load_data = way_data[0];
    end
    else if (associativity == 2)
         begin : data_2
assign load_data = way_match[0] ? way_data[0] : way_data[1];
    end
endgenerate

generate
    if ((addr_offset_width+addr_set_width) < 11)
    begin
// Select data to write to data memories
always @(*)
begin
    if (refill == 1'b1)
        dmem_write_data = refill_data;
    else
    begin
        dmem_write_data[7:0] = store_byte_select[0] ? store_data[7:0] : load_data[7:0];
        dmem_write_data[15:8] = store_byte_select[1] ? store_data[15:8] : load_data[15:8];
        dmem_write_data[23:16] = store_byte_select[2] ? store_data[23:16] : load_data[23:16];
        dmem_write_data[31:24] = store_byte_select[3] ? store_data[31:24] : load_data[31:24];
    end
end
    end
    else
    begin
// Select data to write to data memories - FIXME: Should use different write ports on dual port RAMs, but they don't work
always @(*)
begin
    if (refill == 1'b1)
        dmem_write_data = refill_data;
    else
        dmem_write_data = store_data;
end
    end
endgenerate

// Compute address to use to index into the data memories
generate
     if (bytes_per_line > 4)
assign dmem_write_address = (refill == 1'b1)
                            ? {refill_address[addr_set_msb:addr_set_lsb], refill_offset}
                            : address_m[addr_set_msb:addr_offset_lsb];
    else
assign dmem_write_address = (refill == 1'b1)
                            ? refill_address[addr_set_msb:addr_set_lsb]
                            : address_m[addr_set_msb:addr_offset_lsb];
endgenerate
assign dmem_read_address = address_x[addr_set_msb:addr_offset_lsb];
// Compute address to use to index into the tag memories
assign tmem_write_address = (flushing == 1'b1)
                            ? flush_set
                            : refill_address[addr_set_msb:addr_set_lsb];
assign tmem_read_address = address_x[addr_set_msb:addr_set_lsb];

// Compute signal to indicate when we are on the last refill accesses
generate
    if (bytes_per_line > 4)
assign last_refill = refill_offset == {addr_offset_width{1'b1}};
    else
assign last_refill = 1'b1;
endgenerate

// Compute data and tag memory access enable
assign read_port_enable = (stall_x == 1'b0);
assign write_port_enable = (refill_ready == 1'b1) || !stall_m;

// Determine when we have a valid store
assign valid_store = (store_q_m == 1'b1) && (check == 1'b1);

// Compute data and tag memory write enables
generate
    if (associativity == 1)
    begin : we_1
assign way_dmem_we[0] = (refill_ready == 1'b1) || ((valid_store == 1'b1) && (way_match[0] == 1'b1));
assign way_tmem_we[0] = (refill_ready == 1'b1) || (flushing == 1'b1);
    end
    else
    begin : we_2
assign way_dmem_we[0] = ((refill_ready == 1'b1) && (refill_way_select[0] == 1'b1)) || ((valid_store == 1'b1) && (way_match[0] == 1'b1));
assign way_dmem_we[1] = ((refill_ready == 1'b1) && (refill_way_select[1] == 1'b1)) || ((valid_store == 1'b1) && (way_match[1] == 1'b1));
assign way_tmem_we[0] = ((refill_ready == 1'b1) && (refill_way_select[0] == 1'b1)) || (flushing == 1'b1);
assign way_tmem_we[1] = ((refill_ready == 1'b1) && (refill_way_select[1] == 1'b1)) || (flushing == 1'b1);
    end
endgenerate

// On the last refill cycle set the valid bit, for all other writes it should be cleared
assign tmem_write_data[0] = ((last_refill == 1'b1) || (valid_store == 1'b1)) && (flushing == 1'b0);
assign tmem_write_data[((addr_tag_width+1)-1):1] = refill_address[addr_tag_msb:addr_tag_lsb];

// Signals that indicate which state we are in
assign flushing = state[0];
assign check = state[1];
assign refill = state[2];

assign miss = (~(|way_match)) && (load_q_m == 1'b1) && (stall_m == 1'b0)
        && (~dtlb_miss_x)
        ;
assign stall_request = (check == 1'b0);

/////////////////////////////////////////////////////
// Sequential logic
/////////////////////////////////////////////////////

// Record way selected for replacement on a cache miss
generate
    if (associativity >= 2)
    begin : way_select
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        refill_way_select <= {{associativity-1{1'b0}}, 1'b1};
    else
    begin
        if (refill_request == 1'b1)
            refill_way_select <= {refill_way_select[0], refill_way_select[1]};
    end
end
    end
endgenerate

// Record whether we are currently refilling
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        refilling <= 1'b0;
    else
        refilling <= refill;
end

// Instruction cache control FSM
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        state <= 3'b001;
        flush_set <= {addr_set_width{1'b1}};
        refill_request <= 1'b0;
        refill_address <= {32{1'bx}};
        restart_request <= 1'b0;
    end
    else
    begin
        case (state)

        // Flush the cache
        3'b001:
        begin
            if (flush_set == {addr_set_width{1'b0}})
                state <= 3'b010;
            flush_set <= flush_set - 1'b1;
        end

        // Check for cache misses
        3'b010:
        begin
            if (stall_a == 1'b0)
                restart_request <= 1'b0;
            if (miss == 1'b1)
            begin
                refill_request <= 1'b1;
                refill_address <= address_m;
                state <= 3'b100;
            end
            else if (dflush == 1'b1)
                state <= 3'b001;
        end

        // Refill a cache line
        3'b100:
        begin
            refill_request <= 1'b0;
            if (refill_ready == 1'b1)
            begin
                if (last_refill == 1'b1)
                begin
                    restart_request <= 1'b1;
                    state <= 3'b010;
                end
            end
        end

        endcase
    end
end

generate
    if (bytes_per_line > 4)
    begin
// Refill offset
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        refill_offset <= {addr_offset_width{1'b0}};
    else
    begin
        case (state)

        // Check for cache misses
        3'b010:
        begin
            if (miss == 1'b1)
                refill_offset <= {addr_offset_width{1'b0}};
        end

        // Refill a cache line
        3'b100:
        begin
            if (refill_ready == 1'b1)
                refill_offset <= refill_offset + 1'b1;
        end

        endcase
    end
end
    end
endgenerate

endmodule


