//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project      : LatticeMico32
// File         : lm32_instruction_unit.v
// Title        : Instruction unit
// Dependencies : lm32_include.v
// Version      : 6.1.17
//              : Initial Release
// Version      : 7.0SP2, 3.0
//              : No Change
// Version      : 3.1
//              : Support for static branch prediction is added. Fetching of
//              : instructions can also be altered by branches predicted in D
//              : stage of pipeline, and mispredicted branches in the X and M
//              : stages of the pipeline.
// Version      : 3.2
//              : EBRs use SYNC resets instead of ASYNC resets.
// Version      : 3.3
//              : Support for a non-cacheable Instruction Memory that has a
//              : single-cycle access latency. This memory can be accessed by
//              : data port of LM32 (so that debugger has access to it).
// Version      : 3.4
//              : No change
// Version      : 3.5
//              : Bug fix: Inline memory is correctly generated if it is not a
//              : power-of-two.
//              : Bug fix: Fixed a bug that caused LM32 (configured without
//              : instruction cache) to lock up in to an infinite loop due to a
//              : instruction bus error when EBA was set to instruction inline
//              : memory.
// Version      : 3.8
//              : Feature: Support for dynamically switching EBA to DEBA via a
//              : GPIO.
// =============================================================================

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types


/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_instruction_unit (  
    // ----- Inputs -------
    clk_i,
    rst_i,
    // From pipeline
    stall_a,
    stall_f,
    stall_d,
    stall_x,
    stall_m,
    valid_f,
    valid_d,
    kill_f,
    branch_predict_taken_d,
    branch_predict_address_d,
    exception_m,
    branch_taken_m,
    branch_mispredict_taken_m,
    branch_target_m,
    iflush,
    dcache_restart_request,
    dcache_refill_request,
    dcache_refilling,
    itlb_enable,
    tlbpaddr,
    tlbvaddr,
    itlb_update,
    itlb_flush,
    itlb_invalidate,
    // From Wishbone
    i_dat_i,
    i_ack_i,
    i_err_i,
    // ----- Outputs -------
    // To pipeline
    pc_f,
    pc_d,
    pc_x,
    pc_m,
    pc_w,
    icache_stall_request,
    icache_restart_request,
    icache_refill_request,
    icache_refilling,
    itlb_stall_request,
    itlb_miss_vfn,
    itlb_miss_x,
    // To Wishbone
    i_dat_o,
    i_adr_o,
    i_cyc_o,
    i_sel_o,
    i_stb_o,
    i_we_o,
    i_cti_o,
    i_lock_o,
    i_bte_o,
    bus_error_d,
    instruction_f,
    instruction_d
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter eba_reset = 32'h0;
parameter associativity = 1;                            // Associativity of the cache (Number of ways)
parameter sets = 512;                                   // Number of sets
parameter bytes_per_line = 16;                          // Number of bytes per cache line
parameter base_address = 0;                             // Base address of cachable memory
parameter limit = 0;                                    // Limit (highest address) of cachable memory

// For bytes_per_line == 4, we set 1 so part-select range isn't reversed, even though not really used
localparam addr_offset_width = bytes_per_line == 4 ? 1 : $clog2-2;
localparam addr_offset_lsb = 2;
localparam addr_offset_msb = (addr_offset_lsb+addr_offset_width-1);

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                                            // Clock
input rst_i;                                            // Reset


input stall_a;                                          // Stall A stage instruction
input stall_f;                                          // Stall F stage instruction
input stall_d;                                          // Stall D stage instruction
input stall_x;                                          // Stall X stage instruction
input stall_m;                                          // Stall M stage instruction
input valid_f;                                          // Instruction in F stage is valid
input valid_d;                                          // Instruction in D stage is valid
input kill_f;                                           // Kill instruction in F stage

input branch_predict_taken_d;                           // Branch is predicted taken in D stage
input [((32-2)+2-1):2] branch_predict_address_d;          // Branch target address

input exception_m;
input branch_taken_m;                                   // Branch instruction in M stage is taken
input branch_mispredict_taken_m;                        // Branch instruction in M stage is mispredicted as taken
input [((32-2)+2-1):2] branch_target_m;                   // Target PC of M stage branch instruction

input iflush;                                           // Flush instruction cache
input dcache_restart_request;                           // Restart instruction that caused a data cache miss
input dcache_refill_request;                            // Request to refill data cache
input dcache_refilling;


input itlb_enable;                                      // Instruction TLB enable
input [(32-1):0] tlbpaddr;                        // TLBPADDR CSR
input [(32-1):0] tlbvaddr;                        // TLBVADDR CSR
input itlb_update;                                      // Instruction TLB update request
input itlb_flush;                                       // Instruction TLB flush request
input itlb_invalidate;                                  // Instruction TLB invalidate request

input [(32-1):0] i_dat_i;                         // Instruction Wishbone interface read data
input i_ack_i;                                          // Instruction Wishbone interface acknowledgement
input i_err_i;                                          // Instruction Wishbone interface error


/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output [((32-2)+2-1):2] pc_f;                             // F stage PC
reg    [((32-2)+2-1):2] pc_f;
output [((32-2)+2-1):2] pc_d;                             // D stage PC
reg    [((32-2)+2-1):2] pc_d;
output [((32-2)+2-1):2] pc_x;                             // X stage PC
reg    [((32-2)+2-1):2] pc_x;
output [((32-2)+2-1):2] pc_m;                             // M stage PC
reg    [((32-2)+2-1):2] pc_m;
output [((32-2)+2-1):2] pc_w;                             // W stage PC
reg    [((32-2)+2-1):2] pc_w;

output icache_stall_request;                            // Instruction cache stall request
wire   icache_stall_request;
output icache_restart_request;                          // Request to restart instruction that cached instruction cache miss
wire   icache_restart_request;
output icache_refill_request;                           // Instruction cache refill request
wire   icache_refill_request;
output icache_refilling;                                // Indicates the icache is refilling
wire   icache_refilling;


output itlb_stall_request;                              // Instruction TLB stall request
wire   itlb_stall_request;
output [(32-1):0] itlb_miss_vfn;                  // Virtual frame number of missed instruction
wire   [(32-1):0] itlb_miss_vfn;
output itlb_miss_x;                                     // Indicates if an instruction TLB miss occured in X stage
wire   itlb_miss_x;

output [(32-1):0] i_dat_o;                        // Instruction Wishbone interface write data
wire   [(32-1):0] i_dat_o;
output [(32-1):0] i_adr_o;                        // Instruction Wishbone interface address
reg    [(32-1):0] i_adr_o;
output i_cyc_o;                                         // Instruction Wishbone interface cycle
reg    i_cyc_o;
output [(4-1):0] i_sel_o;                 // Instruction Wishbone interface byte select
wire   [(4-1):0] i_sel_o;
output i_stb_o;                                         // Instruction Wishbone interface strobe
reg    i_stb_o;
output i_we_o;                                          // Instruction Wishbone interface write enable
wire   i_we_o;
output [(3-1):0] i_cti_o;                       // Instruction Wishbone interface cycle type
reg    [(3-1):0] i_cti_o;
output i_lock_o;                                        // Instruction Wishbone interface lock bus
reg    i_lock_o;
output [(2-1):0] i_bte_o;                       // Instruction Wishbone interface burst type
wire   [(2-1):0] i_bte_o;


output bus_error_d;                                     // Indicates a bus error occured while fetching the instruction
reg    bus_error_d;
output [(32-1):0] instruction_f;           // F stage instruction (only to have register indices extracted from)
wire   [(32-1):0] instruction_f;
output [(32-1):0] instruction_d;           // D stage instruction to be decoded
reg    [(32-1):0] instruction_d;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

reg [((32-2)+2-1):2] pc_a;                                // A stage PC

reg [((32-2)+2-1):2] restart_address;                     // Address to restart from after a cache miss

wire icache_read_enable_f;                              // Indicates if instruction cache miss is valid
wire [((32-2)+2-1):2] icache_refill_address;              // Address that caused cache miss
wire [((32-2)+2-1):2] icache_physical_refill_address;     // Physical address that caused cache miss
reg icache_refill_ready;                                // Indicates when next word of refill data is ready to be written to cache
reg [(32-1):0] icache_refill_data;         // Next word of refill data, fetched from Wishbone
wire [(32-1):0] icache_data_f;             // Instruction fetched from instruction cache
wire [(3-1):0] first_cycle_type;                // First Wishbone cycle type
wire [(3-1):0] next_cycle_type;                 // Next Wishbone cycle type
wire last_word;                                         // Indicates if this is the last word in the cache line
wire [((32-2)+2-1):2] first_address;                      // First cache refill address
reg bus_error_f;                                        // Indicates if a bus error occured while fetching the instruction in the F stage



wire [((32-2)+2-1):2] physical_pc_f;                      // F stage physical PC
wire itlb_miss_f;                                       // Indicates if an instruction TLB miss occured in F stage

/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Instantiations
/////////////////////////////////////////////////////

// Instruction ROM

// Instruction cache
lm32_icache #(
    .associativity          (associativity),
    .sets                   (sets),
    .bytes_per_line         (bytes_per_line),
    .base_address           (base_address),
    .limit                  (limit)
    ) icache (
    // ----- Inputs -----
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .stall_a                (stall_a),
    .stall_f                (stall_f),
    .branch_predict_taken_d (branch_predict_taken_d),
    .valid_d                (valid_d),
    .address_a              (pc_a),
    .address_f              (pc_f),
    .physical_address_f     (physical_pc_f),
    .read_enable_f          (icache_read_enable_f),
    .refill_ready           (icache_refill_ready),
    .refill_data            (icache_refill_data),
    .iflush                 (iflush),
    // ----- Outputs -----
    .stall_request          (icache_stall_request),
    .restart_request        (icache_restart_request),
    .refill_request         (icache_refill_request),
    .refill_address         (icache_refill_address),
    .physical_refill_address(icache_physical_refill_address),
    .refilling              (icache_refilling),
    .inst                   (icache_data_f)
    );

// Instruction TLB
lm32_itlb itlb (
    // ----- Inputs -----
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .enable                 (itlb_enable),
    .stall_a                (stall_a),
    .stall_f                (stall_f),
    .stall_d                (stall_d),
    .stall_x                (stall_x),
    .pc_a                   (pc_a),
    .pc_f                   (pc_f),
    .pc_x                   (pc_x),
    .read_enable_f          (icache_read_enable_f),
    .tlbpaddr               (tlbpaddr),
    .tlbvaddr               (tlbvaddr),
    .update                 (itlb_update),
    .flush                  (itlb_flush),
    .invalidate             (itlb_invalidate),
    // ----- Outputs -----
    .physical_pc_f          (physical_pc_f),
    .stall_request          (itlb_stall_request),
    .miss_vfn               (itlb_miss_vfn),
    .miss_f                 (itlb_miss_f),
    .miss_x                 (itlb_miss_x)
    );

/////////////////////////////////////////////////////
// Combinational Logic
/////////////////////////////////////////////////////

// Generate signal that indicates when instruction cache misses are valid
assign icache_read_enable_f =    (valid_f == 1'b1)
                              && (kill_f == 1'b0)
                              && (dcache_restart_request == 1'b0)
                              && (itlb_miss_f == 1'b0)
                              ;

// Compute address of next instruction to fetch
always @(*)
begin
    // The request from the latest pipeline stage must take priority
    if (dcache_restart_request == 1'b1)
        pc_a = restart_address;
    else
      if (branch_taken_m == 1'b1)
        if ((branch_mispredict_taken_m == 1'b1) && (exception_m == 1'b0))
          pc_a = pc_x;
        else
          pc_a = branch_target_m;
      else
        if ( (valid_d == 1'b1) && (branch_predict_taken_d == 1'b1) )
          pc_a = branch_predict_address_d;
        else
          if (icache_restart_request == 1'b1)
            pc_a = restart_address;
          else
            pc_a = pc_f + 1'b1;
end

// Select where instruction should be fetched from

// Select instruction from selected source
assign instruction_f = icache_data_f;

// Unused/constant Wishbone signals
assign i_dat_o = 32'd0;
assign i_we_o = 1'b0;
assign i_sel_o = 4'b1111;
assign i_bte_o = 2'b00;

// Determine parameters for next cache refill Wishbone access
generate
    case (bytes_per_line)
    4:
    begin
assign first_cycle_type = 3'b111;
assign next_cycle_type = 3'b111;
assign last_word = 1'b1;
assign first_address = icache_physical_refill_address;
    end
    8:
    begin
assign first_cycle_type = 3'b010;
assign next_cycle_type = 3'b111;
assign last_word = i_adr_o[addr_offset_msb:addr_offset_lsb] == 1'b1;
assign first_address = {icache_physical_refill_address[(32-2)+2-1:addr_offset_msb+1], {addr_offset_width{1'b0}}};
    end
    default:
    begin
assign first_cycle_type = 3'b010;
assign next_cycle_type = i_adr_o[addr_offset_msb:addr_offset_lsb+1] == {addr_offset_width-1{1'b1}} ? 3'b111 : 3'b010;
assign last_word = (&i_adr_o[addr_offset_msb:addr_offset_lsb]) == 1'b1;
assign first_address = {icache_physical_refill_address[(32-2)+2-1:addr_offset_msb+1], {addr_offset_width{1'b0}}};
    end
    endcase
endgenerate

/////////////////////////////////////////////////////
// Sequential Logic
/////////////////////////////////////////////////////

// PC
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        pc_f <= (eba_reset-4)/4;
        pc_d <= {(32-2){1'b0}};
        pc_x <= {(32-2){1'b0}};
        pc_m <= {(32-2){1'b0}};
        pc_w <= {(32-2){1'b0}};
    end
    else
    begin
        if (stall_f == 1'b0)
            pc_f <= pc_a;
        if (stall_d == 1'b0)
            pc_d <= pc_f;
        if (stall_x == 1'b0)
            pc_x <= pc_d;
        if (stall_m == 1'b0)
            pc_m <= pc_x;
        pc_w <= pc_m;
    end
end

// Address to restart from after a cache miss has been handled
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        restart_address <= {(32-2){1'b0}};
    else
    begin
            // D-cache restart address must take priority, otherwise instructions will be lost
            if (dcache_refill_request == 1'b1)
                restart_address <= pc_w;
            else if ((icache_refill_request == 1'b1) && (!dcache_refilling) && (!dcache_restart_request))
                restart_address <= icache_refill_address;
    end
end

// Record where instruction was fetched from


// Instruction Wishbone interface
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        i_cyc_o <= 1'b0;
        i_stb_o <= 1'b0;
        i_adr_o <= {32{1'b0}};
        i_cti_o <= 3'b111;
        i_lock_o <= 1'b0;
        icache_refill_data <= {32{1'b0}};
        icache_refill_ready <= 1'b0;
        bus_error_f <= 1'b0;
    end
    else
    begin
        icache_refill_ready <= 1'b0;
        // Is a cycle in progress?
        if (i_cyc_o == 1'b1)
        begin
            // Has cycle completed?
            if ((i_ack_i == 1'b1) || (i_err_i == 1'b1))
            begin
                begin
                    if (last_word == 1'b1)
                    begin
                        // Cache line fill complete
                        i_cyc_o <= 1'b0;
                        i_stb_o <= 1'b0;
                        i_lock_o <= 1'b0;
                    end
                    // Fetch next word in cache line
                    i_adr_o[addr_offset_msb:addr_offset_lsb] <= i_adr_o[addr_offset_msb:addr_offset_lsb] + 1'b1;
                    i_cti_o <= next_cycle_type;
                    // Write fetched data into instruction cache
                    icache_refill_ready <= 1'b1;
                    icache_refill_data <= i_dat_i;
                end
            end
            if (i_err_i == 1'b1)
            begin
                bus_error_f <= 1'b1;
                $display ("Instruction bus error. Address: %x", i_adr_o);
            end
        end
        else
        begin
            if ((icache_refill_request == 1'b1) && (icache_refill_ready == 1'b0))
            begin
                // Read first word of cache line
                i_adr_o <= {first_address, 2'b00};
                i_cyc_o <= 1'b1;
                i_stb_o <= 1'b1;
                i_cti_o <= first_cycle_type;
                //i_lock_o <= `TRUE;
                bus_error_f <= 1'b0;
            end
            // Clear bus error when exception taken, otherwise they would be
            // continually generated if exception handler is cached
            if (branch_taken_m == 1'b1)
                bus_error_f <= 1'b0;
        end
    end
end

// Instruction register
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        instruction_d <= {32{1'b0}};
        bus_error_d <= 1'b0;
    end
    else
    begin
        if (stall_d == 1'b0)
        begin
            instruction_d <= instruction_f;
            bus_error_d <= bus_error_f;
        end
    end
end

endmodule  