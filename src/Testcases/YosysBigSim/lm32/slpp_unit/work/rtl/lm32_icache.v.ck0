//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_icache.v
// Title            : Instruction cache
// Dependencies     : lm32_include.v
//
// Version 3.5
// 1. Bug Fix: Instruction cache flushes issued from Instruction Inline Memory
//    cause segmentation fault due to incorrect fetches.
//
// Version 3.1
// 1. Feature: Support for user-selected resource usage when implementing
//    cache memory. Additional parameters must be defined when invoking module
//    lm32_ram. Instruction cache miss mechanism is dependent on branch
//    prediction being performed in D stage of pipeline.
//
// Version 7.0SP2, 3.0
// No change
// =============================================================================

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types







/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_icache (  
    // ----- Inputs -----
    clk_i,
    rst_i,
    stall_a,
    stall_f,
    address_a,
    address_f,
    physical_address_f,
    read_enable_f,
    refill_ready,
    refill_data,
    iflush,
    valid_d,
    branch_predict_taken_d,
    // ----- Outputs -----
    stall_request,
    restart_request,
    refill_request,
    refill_address,
    physical_refill_address,
    refilling,
    inst
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter associativity = 1;                            // Associativity of the cache (Number of ways)
parameter sets = 512;                                   // Number of sets
parameter bytes_per_line = 16;                          // Number of bytes per cache line
parameter base_address = 0;                             // Base address of cachable memory
parameter limit = 0;                                    // Limit (highest address) of cachable memory

localparam addr_offset_width = $clog2-2;
localparam addr_set_width = $clog2;
localparam addr_offset_lsb = 2;
localparam addr_offset_msb = (addr_offset_lsb+addr_offset_width-1);
localparam addr_set_lsb = (addr_offset_msb+1);
localparam addr_set_msb = (addr_set_lsb+addr_set_width-1);
localparam addr_tag_lsb = (addr_offset_msb+1);
localparam addr_tag_msb = $clog2;
localparam addr_tag_width = (addr_tag_msb-addr_tag_lsb+1);

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                                        // Clock
input rst_i;                                        // Reset

input stall_a;                                      // Stall instruction in A stage
input stall_f;                                      // Stall instruction in F stage

input valid_d;                                      // Valid instruction in D stage
input branch_predict_taken_d;                       // Instruction in D stage is a branch and is predicted taken

input [((32-2)+2-1):2] address_a;                     // Address of instruction in A stage
input [((32-2)+2-1):2] address_f;                     // Address of instruction in F stage
input [((32-2)+2-1):2] physical_address_f;            // Physical address of instruction in F stage
input read_enable_f;                                // Indicates if cache access is valid

input refill_ready;                                 // Next word of refill data is ready
input [(32-1):0] refill_data;          // Data to refill the cache with

input iflush;                                       // Flush the cache

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output stall_request;                               // Request to stall the pipeline
wire   stall_request;
output restart_request;                             // Request to restart instruction that caused the cache miss
reg    restart_request;
output refill_request;                              // Request to refill a cache line
wire   refill_request;
output [((32-2)+2-1):2] refill_address;               // Base address of cache refill
reg    [((32-2)+2-1):2] refill_address;
output [((32-2)+2-1):2] physical_refill_address;      // Physical base address of cache refill
reg    [((32-2)+2-1):2] physical_refill_address;
output refilling;                                   // Indicates the instruction cache is currently refilling
reg    refilling;
output [(32-1):0] inst;                // Instruction read from cache
wire   [(32-1):0] inst;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

wire enable;
wire [0:associativity-1] way_mem_we;
wire [(32-1):0] way_data[0:associativity-1];
wire [((addr_tag_width+1)-1):1] way_tag[0:associativity-1];
wire [0:associativity-1] way_valid;
wire [0:associativity-1] way_match;
wire miss;

wire [(addr_set_width-1):0] tmem_read_address;
wire [(addr_set_width-1):0] tmem_write_address;
wire [((addr_offset_width+addr_set_width)-1):0] dmem_read_address;
wire [((addr_offset_width+addr_set_width)-1):0] dmem_write_address;
wire [((addr_tag_width+1)-1):0] tmem_write_data;

reg [3:0] state;
wire flushing;
wire check;
wire refill;

reg [associativity-1:0] refill_way_select;
reg [addr_offset_msb:addr_offset_lsb] refill_offset;
wire last_refill;
reg [(addr_set_width-1):0] flush_set;

genvar i;

/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Instantiations
/////////////////////////////////////////////////////

   generate
      for (i = 0; i < associativity; i = i + 1)
        begin : memories

           lm32_ram
             #(
               // ----- Parameters -------
               .data_width                 (32),
               .address_width              ((addr_offset_width+addr_set_width))
// Modified for Milkymist: removed non-portable RAM parameters
)
           way_0_data_ram
             (
              // ----- Inputs -------
              .read_clk                   (clk_i),
              .write_clk                  (clk_i),
              .reset                      (rst_i),
              .read_address               (dmem_read_address),
              .enable_read                (enable),
              .write_address              (dmem_write_address),
              .enable_write               (1'b1),
              .write_enable               (way_mem_we[i]),
              .write_data                 (refill_data),
              // ----- Outputs -------
              .read_data                  (way_data[i])
              );

           lm32_ram
             #(
               // ----- Parameters -------
               .data_width                 ((addr_tag_width+1)),
               .address_width              (addr_set_width)
// Modified for Milkymist: removed non-portable RAM parameters
               )
           way_0_tag_ram
             (
              // ----- Inputs -------
              .read_clk                   (clk_i),
              .write_clk                  (clk_i),
              .reset                      (rst_i),
              .read_address               (tmem_read_address),
              .enable_read                (enable | flushing),
              .write_address              (tmem_write_address),
              .enable_write               (1'b1),
              .write_enable               (way_mem_we[i] | flushing),
              .write_data                 (tmem_write_data),
              // ----- Outputs -------
              .read_data                  ({way_tag[i], way_valid[i]})
              );

        end
endgenerate

/////////////////////////////////////////////////////
// Combinational logic
/////////////////////////////////////////////////////

// Compute which ways in the cache match the address address being read
generate
    for (i = 0; i < associativity; i = i + 1)
    begin : match
assign way_match[i] =
        ({way_tag[i], way_valid[i]} == {physical_address_f[addr_tag_msb:addr_tag_lsb], 1'b1});
    end
endgenerate

// Select data from way that matched the address being read
generate
    if (associativity == 1)
    begin : inst_1
assign inst = way_match[0] ? way_data[0] : 32'b0;
    end
    else if (associativity == 2)
         begin : inst_2
assign inst = way_match[0] ? way_data[0] : (way_match[1] ? way_data[1] : 32'b0);
    end
endgenerate

// Compute address to use to index into the data memories
generate
    if (bytes_per_line > 4)
assign dmem_write_address = {refill_address[addr_set_msb:addr_set_lsb], refill_offset};
    else
assign dmem_write_address = refill_address[addr_set_msb:addr_set_lsb];
endgenerate

assign dmem_read_address = address_a[addr_set_msb:addr_offset_lsb];

// Compute address to use to index into the tag memories
assign tmem_read_address = address_a[addr_set_msb:addr_set_lsb];
assign tmem_write_address = flushing
                                ? flush_set
                                : refill_address[addr_set_msb:addr_set_lsb];

// Compute signal to indicate when we are on the last refill accesses
generate
    if (bytes_per_line > 4)
assign last_refill = refill_offset == {addr_offset_width{1'b1}};
    else
assign last_refill = 1'b1;
endgenerate

// Compute data and tag memory access enable
assign enable = (stall_a == 1'b0);

// Compute data and tag memory write enables
generate
    if (associativity == 1)
    begin : we_1
assign way_mem_we[0] = (refill_ready == 1'b1);
    end
    else
    begin : we_2
assign way_mem_we[0] = (refill_ready == 1'b1) && (refill_way_select[0] == 1'b1);
assign way_mem_we[1] = (refill_ready == 1'b1) && (refill_way_select[1] == 1'b1);
    end
endgenerate

// On the last refill cycle set the valid bit, for all other writes it should be cleared
assign tmem_write_data[0] = last_refill & !flushing;
assign tmem_write_data[((addr_tag_width+1)-1):1] =
       physical_refill_address[addr_tag_msb:addr_tag_lsb];

// Signals that indicate which state we are in
assign flushing = |state[1:0];
assign check = state[2];
assign refill = state[3];

assign miss = (~(|way_match)) && (read_enable_f == 1'b1) && (stall_f == 1'b0) && !(valid_d && branch_predict_taken_d);
assign stall_request = (check == 1'b0);
assign refill_request = (refill == 1'b1);

/////////////////////////////////////////////////////
// Sequential logic
/////////////////////////////////////////////////////

// Record way selected for replacement on a cache miss
generate
    if (associativity >= 2)
    begin : way_select
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        refill_way_select <= {{associativity-1{1'b0}}, 1'b1};
    else
    begin
        if (miss == 1'b1)
            refill_way_select <= {refill_way_select[0], refill_way_select[1]};
    end
end
    end
endgenerate

// Record whether we are refilling
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        refilling <= 1'b0;
    else
        refilling <= refill;
end

// Instruction cache control FSM
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        state <= 4'b0001;
        flush_set <= {addr_set_width{1'b1}};
        refill_address <= {(32-2){1'b0}};
        physical_refill_address <= {(32-2){1'b0}};
        restart_request <= 1'b0;
    end
    else
    begin
        case (state)

        // Flush the cache for the first time after reset
        4'b0001:
        begin
            if (flush_set == {addr_set_width{1'b0}})
                state <= 4'b0100;
            flush_set <= flush_set - 1'b1;
        end

        // Flush the cache in response to an write to the ICC CSR
        4'b0010:
        begin
            if (flush_set == {addr_set_width{1'b0}})
                state <= 4'b0100;

            flush_set <= flush_set - 1'b1;
        end

        // Check for cache misses
        4'b0100:
        begin
            if (stall_a == 1'b0)
                restart_request <= 1'b0;
            if (iflush == 1'b1)
            begin
                physical_refill_address <= physical_address_f;
                refill_address <= address_f;
                state <= 4'b0010;
            end
            else if (miss == 1'b1)
            begin
                physical_refill_address <= physical_address_f;
                refill_address <= address_f;
                state <= 4'b1000;
            end
        end

        // Refill a cache line
        4'b1000:
        begin
            if (refill_ready == 1'b1)
            begin
                if (last_refill == 1'b1)
                begin
                    restart_request <= 1'b1;
                    state <= 4'b0100;
                end
            end
        end

        endcase
    end
end

generate
    if (bytes_per_line > 4)
    begin
// Refill offset
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        refill_offset <= {addr_offset_width{1'b0}};
    else
    begin
        case (state)

        // Check for cache misses
        4'b0100:
        begin
            if (iflush == 1'b1)
                refill_offset <= {addr_offset_width{1'b0}};
            else if (miss == 1'b1)
                refill_offset <= {addr_offset_width{1'b0}};
        end

        // Refill a cache line
        4'b1000:
        begin
            if (refill_ready == 1'b1)
                refill_offset <= refill_offset + 1'b1;
        end

        endcase
    end
end
    end
endgenerate

endmodule

  