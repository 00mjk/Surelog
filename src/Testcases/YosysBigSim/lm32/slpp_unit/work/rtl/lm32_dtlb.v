/*
 * LatticeMico32
 * Data Translation Lookaside Buffer
 *
 * Copyright (c) 2011-2012 Yann Sionneau <yann.sionneau@gmail.com>
 * Copyright (c) 2012 Michael Walle <michael@walle.cc>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types






/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_dtlb (
    // ----- Inputs -------
    clk_i,
    rst_i,
    enable,
    stall_x,
    stall_m,
    address_x,
    address_m,
    load_d,
    store_d,
    load_q_x,
    store_q_x,
    load_q_m,
    store_q_m,
    tlbpaddr,
    tlbvaddr,
    update,
    flush,
    invalidate,
    // ----- Outputs -----
    physical_load_store_address_m,
    stall_request,
    miss_vfn,
    miss_x,
    fault_x,
    cache_inhibit_x
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter entries = 1024;               // Number of entries in DTLB
parameter page_size = 4096;             // DTLB page size

localparam offset_width = $clog2;
localparam index_width = $clog2;
localparam offset_lsb = 0;
localparam offset_msb = (offset_lsb+offset_width-1);
localparam index_lsb = (offset_msb+1);
localparam index_msb = (index_lsb+index_width-1);
localparam tag_lsb = (index_msb+1);
localparam tag_msb = (32-1);
localparam tag_width = (tag_msb-tag_lsb+1);
localparam vpfn_lsb = (offset_msb+1);
localparam vpfn_msb = (32-1);
localparam vpfn_width = (vpfn_msb-vpfn_lsb+1);

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                            // Clock
input rst_i;                            // Reset

input enable;                           // Data TLB enable

input stall_x;                          // Stall X stage
input stall_m;                          // Stall M stage

input [(32-1):0] address_x;       // X stage load/store address
input [(32-1):0] address_m;       // M stage load/store address
input load_d;                           // Load instruction in D stage
input store_d;                          // Store instruction in D stage
input load_q_x;                         // Load instruction in X stage
input store_q_x;                        // Store instruction in X stage
input load_q_m;                         // Load instruction in M stage
input store_q_m;                        // Store instruction in M stage

input [(32-1):0] tlbpaddr;
input [(32-1):0] tlbvaddr;
input update;
input flush;
input invalidate;

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output [(32-1):0] physical_load_store_address_m;
wire   [(32-1):0] physical_load_store_address_m;
output stall_request;
wire   stall_request;
output [(32-1):0] miss_vfn;
wire   [(32-1):0] miss_vfn;
output miss_x;
wire   miss_x;
output fault_x;
wire   fault_x;
output cache_inhibit_x;
wire   cache_inhibit_x;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

wire [(index_width-1):0] read_address;
wire [(index_width-1):0] write_address;
wire [((vpfn_width+tag_width+3)  -1):0] write_data;
wire [((vpfn_width+tag_width+3)  -1):0] tlbe;
wire [((vpfn_width+tag_width+3)  -1):0] tlbe_inval;
wire [tag_msb:tag_lsb] tlbe_tag_x;
wire [vpfn_msb:vpfn_lsb] tlbe_pfn_x;
wire tlbe_valid_x;
wire tlbe_ro_x;
wire tlbe_ci_x;
wire checking;
wire flushing;
wire write_port_enable;

reg [1:0] state;                         // Current state of FSM
reg [(index_width-1):0] flush_set;
reg [vpfn_msb:vpfn_lsb] tlbe_pfn_m;
reg lookup;


/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

////////////////////////////////////////////////////
// Instantiations
/////////////////////////////////////////////////////

lm32_ram
  #(
    // ----- Parameters -------
    .data_width ((vpfn_width+tag_width+3)  ),
    .address_width (index_width)
// Modified for Milkymist: removed non-portable RAM parameters
    ) data_ram
    (
     // ----- Inputs -------
     .read_clk (clk_i),
     .write_clk (clk_i),
     .reset (rst_i),
     .read_address (read_address),
     .enable_read (lookup),
     .write_address (write_address),
     .enable_write (1'b1),
     .write_enable (write_port_enable),
     .write_data (write_data),
     // ----- Outputs -------
     .read_data ({tlbe_pfn_x, tlbe_tag_x, tlbe_ci_x, tlbe_ro_x, tlbe_valid_x})
     );

/////////////////////////////////////////////////////
// Combinational logic
/////////////////////////////////////////////////////

// Compute address to use to index into the DTLB data memory
assign read_address = address_x[index_msb:index_lsb];

// tlb_update_address will receive data from a CSR register
assign write_address = (flushing == 1'b1)
                            ? flush_set
                            : tlbvaddr[index_msb:index_lsb];

assign write_port_enable = (update == 1'b1) || (invalidate == 1'b1) || (flushing == 1'b1);

assign physical_load_store_address_m = (enable == 1'b0)
                ? address_m
                : {tlbe_pfn_m, address_m[offset_msb:offset_lsb]};

assign tlbe = {
        tlbpaddr[vpfn_msb:vpfn_lsb],     // pfn
        tlbvaddr[tag_msb:tag_lsb],      // tag
        tlbpaddr[2],                       // cache inhibit
        tlbpaddr[1],                       // read only
        1'b1};                            // valid
assign tlbe_inval = {{(vpfn_width+tag_width+3)  -1{1'b0}}, 1'b0};
assign write_data = ((invalidate == 1'b1) || (flushing)) ? tlbe_inval : tlbe;


assign tlbe_match = ({tlbe_tag_x, tlbe_valid_x} == {address_x[tag_msb:tag_lsb], 1'b1});

assign miss_vfn = {address_x[vpfn_msb:vpfn_lsb], {offset_width{1'b0}}};
assign miss_x = ((enable == 1'b1) && ((load_q_x == 1'b1) || (store_q_x == 1'b1)) && (tlbe_match == 1'b0) && (lookup == 1'b0));
assign cache_inhibit_x = ((enable == 1'b1) && (tlbe_ci_x == 1'b1));
assign fault_x = ((enable == 1'b1) && (store_q_x == 1'b1) && (tlbe_match == 1'b1) && (tlbe_ro_x == 1'b1));

assign checking = state[0];
assign flushing = state[1];
assign stall_request = (flushing == 1'b1) || (lookup == 1'b1);

/////////////////////////////////////////////////////
// Sequential logic
/////////////////////////////////////////////////////

// Lookup logic
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        lookup <= 1'b0;
    else
    begin
        if ((enable == 1'b1) && (stall_x == 1'b0) && ((load_d == 1'b1) || (store_d == 1'b1)))
            lookup <= 1'b1;
        else
            lookup <= 1'b0;
    end
end

// X/M stage registers
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        tlbe_pfn_m <= {vpfn_width{1'bx}};
    else if (stall_m == 1'b0)
        tlbe_pfn_m <= tlbe_pfn_x;
end

always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        flush_set <= {index_width{1'b1}};
        state <= 2'b10;
    end
    else
    begin
        case (state)

        2'b01:
        begin
            if (flush == 1'b1) begin
                flush_set <= {index_width{1'b1}};
                state <= 2'b10;
            end
        end

        2'b10:
        begin
            if (flush_set == {index_width{1'b0}})
                state <= 2'b01;
            flush_set <= flush_set - 1'b1;
        end

        endcase
    end
end

endmodule


