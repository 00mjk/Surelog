//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm_mc_arithmetic.v
// Title            : Multi-cycle arithmetic unit.
// Dependencies     : lm32_include.v
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// =============================================================================

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types



/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_mc_arithmetic (
    // ----- Inputs -----
    clk_i,
    rst_i,
    stall_d,
    kill_x,
    divide_d,
    modulus_d,
    operand_0_d,
    operand_1_d,
    // ----- Ouputs -----
    result_x,
    divide_by_zero_x,
    stall_request_x
    );

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                                    // Clock
input rst_i;                                    // Reset
input stall_d;                                  // Stall instruction in D stage
input kill_x;                                   // Kill instruction in X stage
input divide_d;                                 // Perform divide
input modulus_d;                                // Perform modulus
input [(32-1):0] operand_0_d;
input [(32-1):0] operand_1_d;

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output [(32-1):0] result_x;               // Result of operation
reg    [(32-1):0] result_x;
output divide_by_zero_x;                        // A divide by zero was attempted
reg    divide_by_zero_x;
output stall_request_x;                         // Request to stall pipeline from X stage back
wire   stall_request_x;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

reg [(32-1):0] p;                         // Temporary registers
reg [(32-1):0] a;
reg [(32-1):0] b;
wire [32:0] t;

reg [2:0] state;                 // Current state of FSM
reg [5:0] cycles;                               // Number of cycles remaining in the operation


/////////////////////////////////////////////////////
// Combinational logic
/////////////////////////////////////////////////////

// Stall pipeline while any operation is being performed
assign stall_request_x = state != 3'b000;

// Subtraction
assign t = {p[32-2:0], a[32-1]} - b;


/////////////////////////////////////////////////////
// Sequential logic
/////////////////////////////////////////////////////

// Perform right shift
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        cycles <= {6{1'b0}};
        p <= {32{1'b0}};
        a <= {32{1'b0}};
        b <= {32{1'b0}};
        divide_by_zero_x <= 1'b0;
        result_x <= {32{1'b0}};
        state <= 3'b000;
    end
    else
    begin
        divide_by_zero_x <= 1'b0;
        case (state)
        3'b000:
        begin
            if (stall_d == 1'b0)
            begin
                cycles <= 32;
                p <= 32'b0;
                a <= operand_0_d;
                b <= operand_1_d;
                if (divide_d == 1'b1)
                    state <= 3'b011;
                if (modulus_d == 1'b1)
                    state <= 3'b010;
            end
        end
        3'b011:
        begin
            if (t[32] == 1'b0)
            begin
                p <= t[31:0];
                a <= {a[32-2:0], 1'b1};
            end
            else
            begin
                p <= {p[32-2:0], a[32-1]};
                a <= {a[32-2:0], 1'b0};
            end
            result_x <= a;
            if ((cycles == 32'd0) || (kill_x == 1'b1))
            begin
                // Check for divide by zero
                divide_by_zero_x <= b == {32{1'b0}};
                state <= 3'b000;
            end
            cycles <= cycles - 1'b1;
        end
        3'b010:
        begin
            if (t[32] == 1'b0)
            begin
                p <= t[31:0];
                a <= {a[32-2:0], 1'b1};
            end
            else
            begin
                p <= {p[32-2:0], a[32-1]};
                a <= {a[32-2:0], 1'b0};
            end
            result_x <= p;
            if ((cycles == 32'd0) || (kill_x == 1'b1))
            begin
                // Check for divide by zero
                divide_by_zero_x <= b == {32{1'b0}};
                state <= 3'b000;
            end
            cycles <= cycles - 1'b1;
        end
        endcase
    end
end

endmodule
