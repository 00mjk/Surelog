//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_debug.v
// Title            : Hardware debug registers and associated logic.
// Dependencies     : lm32_include.v
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : Fixed simulation bug which flares up when number of
//                  : watchpoints is zero.
// =============================================================================

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types



// States for single-step FSM

/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_debug (
    // ----- Inputs -------
    clk_i,
    rst_i,
    pc_x,
    load_x,
    store_x,
    load_store_address_x,
    csr_write_enable_x,
    csr_write_data,
    csr_x,
    eret_q_x,
    bret_q_x,
    stall_x,
    exception_x,
    q_x,
    dcache_refill_request,
    // ----- Outputs -------
    dc_ss,
    dc_re,
    bp_match,
    wp_match
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter breakpoints = 0;                      // Number of breakpoint CSRs
parameter watchpoints = 0;                      // Number of watchpoint CSRs

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                                    // Clock
input rst_i;                                    // Reset

input [((32-2)+2-1):2] pc_x;                      // X stage PC
input load_x;                                   // Load instruction in X stage
input store_x;                                  // Store instruction in X stage
input [(32-1):0] load_store_address_x;    // Load or store effective address
input csr_write_enable_x;                       // wcsr instruction in X stage
input [(32-1):0] csr_write_data;          // Data to write to CSR
input [(5-1):0] csr_x;                    // Which CSR to write
input eret_q_x;                                 // eret instruction in X stage
input bret_q_x;                                 // bret instruction in X stage
input stall_x;                                  // Instruction in X stage is stalled
input exception_x;                              // An exception has occured in X stage
input q_x;                                      // Indicates the instruction in the X stage is qualified
input dcache_refill_request;                    // Indicates data cache wants to be refilled

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output dc_ss;                                   // Single-step enable
reg    dc_ss;
output dc_re;                                   // Remap exceptions
reg    dc_re;
output bp_match;                                // Indicates a breakpoint has matched
wire   bp_match;
output wp_match;                                // Indicates a watchpoint has matched
wire   wp_match;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

genvar i;                                       // Loop index for generate statements

// Debug CSRs

reg [((32-2)+2-1):2] bp_a[0:breakpoints-1];       // Instruction breakpoint address
reg bp_e[0:breakpoints-1];                      // Instruction breakpoint enable
wire [0:breakpoints-1]bp_match_n;               // Indicates if a h/w instruction breakpoint matched

reg [1:0] wpc_c[0:watchpoints-1];   // Watchpoint enable
reg [(32-1):0] wp[0:watchpoints-1];       // Watchpoint address
wire [0:watchpoints-1]wp_match_n;               // Indicates if a h/w data watchpoint matched

wire debug_csr_write_enable;                    // Debug CSR write enable (from either a wcsr instruction of external debugger)
wire [(32-1):0] debug_csr_write_data;     // Data to write to debug CSR
wire [(5-1):0] debug_csr;                 // Debug CSR to write to

// FIXME: Declaring this as a reg causes ModelSim 6.1.15b to crash, so use integer for now
//reg [`LM32_DEBUG_SS_STATE_RNG] state;           // State of single-step FSM
integer state;                                  // State of single-step FSM

/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Combinational Logic
/////////////////////////////////////////////////////

// Check for breakpoints
generate
    for (i = 0; i < breakpoints; i = i + 1)
    begin : bp_comb
assign bp_match_n[i] = ((bp_a[i] == pc_x) && (bp_e[i] == 1'b1));
    end
endgenerate
generate
    if (breakpoints > 0)
assign bp_match = (|bp_match_n) || (state == 3'b011);
    else
assign bp_match = state == 3'b011;
endgenerate

// Check for watchpoints
generate
    for (i = 0; i < watchpoints; i = i + 1)
    begin : wp_comb
assign wp_match_n[i] = (wp[i] == load_store_address_x) && ((load_x & wpc_c[i][0]) | (store_x & wpc_c[i][1]));
    end
endgenerate
generate
    if (watchpoints > 0)
assign wp_match = |wp_match_n;
    else
assign wp_match = 1'b0;
endgenerate

assign debug_csr_write_enable = csr_write_enable_x;
assign debug_csr_write_data = csr_write_data;
assign debug_csr = csr_x;

/////////////////////////////////////////////////////
// Sequential Logic
/////////////////////////////////////////////////////

// Breakpoint address and enable CSRs
generate
    for (i = 0; i < breakpoints; i = i + 1)
    begin : bp_seq
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        bp_a[i] <= {(32-2){1'bx}};
        bp_e[i] <= 1'b0;
    end
    else
    begin
        if ((debug_csr_write_enable == 1'b1) && (debug_csr == 5'h10 + i))
        begin
            bp_a[i] <= debug_csr_write_data[((32-2)+2-1):2];
            bp_e[i] <= debug_csr_write_data[0];
        end
    end
end
    end
endgenerate

// Watchpoint address and control flags CSRs
generate
    for (i = 0; i < watchpoints; i = i + 1)
    begin : wp_seq
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        wp[i] <= {32{1'bx}};
        wpc_c[i] <= 2'b00;
    end
    else
    begin
        if (debug_csr_write_enable == 1'b1)
        begin
            if (debug_csr == 5'h8)
                wpc_c[i] <= debug_csr_write_data[3+i*2:2+i*2];
            if (debug_csr == 5'h18 + i)
                wp[i] <= debug_csr_write_data;
        end
    end
end
    end
endgenerate

// Remap exceptions control bit
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        dc_re <= 1'b0;
    else
    begin
        if ((debug_csr_write_enable == 1'b1) && (debug_csr == 5'h8))
            dc_re <= debug_csr_write_data[1];
    end
end

// Single-step control flag
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        state <= 3'b000;
        dc_ss <= 1'b0;
    end
    else
    begin
        if ((debug_csr_write_enable == 1'b1) && (debug_csr == 5'h8))
        begin
            dc_ss <= debug_csr_write_data[0];
            if (debug_csr_write_data[0] == 1'b0)
                state <= 3'b000;
            else
                state <= 3'b001;
        end
        case (state)
        3'b001:
        begin
            // Wait for eret or bret instruction to be executed
            if (   (   (eret_q_x == 1'b1)
                    || (bret_q_x == 1'b1)
                    )
                && (stall_x == 1'b0)
               )
                state <= 3'b010;
        end
        3'b010:
        begin
            // Wait for an instruction to be executed
            if ((q_x == 1'b1) && (stall_x == 1'b0))
                state <= 3'b011;
        end
        3'b011:
        begin
            // Wait for exception to be raised
            if (dcache_refill_request == 1'b1)
                state <= 3'b010;
            else
                 if ((exception_x == 1'b1) && (q_x == 1'b1) && (stall_x == 1'b0))
            begin
                dc_ss <= 1'b0;
                state <= 3'b100;
            end
        end
        3'b100:
        begin
            // Watch to see if stepped instruction is restarted due to a cache miss
            if (dcache_refill_request == 1'b1)
                state <= 3'b010;
            else
                state <= 3'b000;
        end
        endcase
    end
end

endmodule

