//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project      : LatticeMico32
// File         : lm32_load_store_unit.v
// Title        : Load and store unit
// Dependencies : lm32_include.v
// Version      : 6.1.17
//              : Initial Release
// Version      : 7.0SP2, 3.0
//              : No Change
// Version      : 3.1
//              : Instead of disallowing an instruction cache miss on a data cache
//              : miss, both can now occur at the same time. If both occur at same
//              : time, then restart address is the address of instruction that
//              : caused data cache miss.
// Version      : 3.2
//              : EBRs use SYNC resets instead of ASYNC resets.
// Version      : 3.3
//              : Support for new non-cacheable Data Memory that is accessible by
//              : the data port and has a one cycle access latency.
// Version      : 3.4
//              : No change
// Version      : 3.5
//              : Bug fix: Inline memory is correctly generated if it is not a
//              : power-of-two
// =============================================================================

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types


/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_load_store_unit (  
    // ----- Inputs -------
    clk_i,
    rst_i,
    // From pipeline
    stall_a,
    stall_x,
    stall_m,
    kill_m,
    exception_m,
    store_operand_x,
    load_store_address_x,
    load_store_address_m,
    load_store_address_w,
    load_d,
    store_d,
    load_x,
    store_x,
    load_q_x,
    store_q_x,
    load_q_m,
    store_q_m,
    sign_extend_x,
    size_x,
    dflush,
    dtlb_enable,
    tlbpaddr,
    tlbvaddr,
    dtlb_update,
    dtlb_flush,
    dtlb_invalidate,
    // From Wishbone
    d_dat_i,
    d_ack_i,
    d_err_i,
    d_rty_i,
    // ----- Outputs -------
    // To pipeline
    dcache_refill_request,
    dcache_restart_request,
    dcache_stall_request,
    dcache_refilling,
    load_data_w,
    stall_wb_load,
    dtlb_stall_request,
    dtlb_miss_vfn,
    dtlb_miss_x,
    dtlb_fault_x,
    // To Wishbone
    d_dat_o,
    d_adr_o,
    d_cyc_o,
    d_sel_o,
    d_stb_o,
    d_we_o,
    d_cti_o,
    d_lock_o,
    d_bte_o
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter associativity = 1;                            // Associativity of the cache (Number of ways)
parameter sets = 512;                                   // Number of sets
parameter bytes_per_line = 16;                          // Number of bytes per cache line
parameter base_address = 0;                             // Base address of cachable memory
parameter limit = 0;                                    // Limit (highest address) of cachable memory

// For bytes_per_line == 4, we set 1 so part-select range isn't reversed, even though not really used
localparam addr_offset_width = bytes_per_line == 4 ? 1 : $clog2-2;
localparam addr_offset_lsb = 2;
localparam addr_offset_msb = (addr_offset_lsb+addr_offset_width-1);

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                                            // Clock
input rst_i;                                            // Reset

input stall_a;                                          // A stage stall
input stall_x;                                          // X stage stall
input stall_m;                                          // M stage stall
input kill_m;                                           // Kill instruction in M stage
input exception_m;                                      // An exception occured in the M stage

input [(32-1):0] store_operand_x;                 // Data read from register to store
input [(32-1):0] load_store_address_x;            // X stage load/store address
input [(32-1):0] load_store_address_m;            // M stage load/store address
input [1:0] load_store_address_w;                       // W stage load/store address (only least two significant bits are needed)
input load_d;                                           // Load instruction in D stage
input store_d;                                          // Store instruction in D stage
input load_x;                                           // Load instruction in X stage
input store_x;                                          // Store instruction in X stage
input load_q_x;                                         // Load instruction in X stage
input store_q_x;                                        // Store instruction in X stage
input load_q_m;                                         // Load instruction in M stage
input store_q_m;                                        // Store instruction in M stage
input sign_extend_x;                                    // Whether load instruction in X stage should sign extend or zero extend
input [1:0] size_x;                          // Size of load or store (byte, hword, word)

input dflush;                                           // Flush the data cache


input dtlb_enable;                                      // Data TLB enable
input [(32-1):0] tlbpaddr;                        // TLBPADDR CSR
input [(32-1):0] tlbvaddr;                        // TLBVADDR CSR
input dtlb_update;                                      // Data TLB update
input dtlb_flush;                                       // Data TLB flush
input dtlb_invalidate;                                  // Data TLB invalidate

input [(32-1):0] d_dat_i;                         // Data Wishbone interface read data
input d_ack_i;                                          // Data Wishbone interface acknowledgement
input d_err_i;                                          // Data Wishbone interface error
input d_rty_i;                                          // Data Wishbone interface retry

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output dcache_refill_request;                           // Request to refill data cache
wire   dcache_refill_request;
output dcache_restart_request;                          // Request to restart the instruction that caused a data cache miss
wire   dcache_restart_request;
output dcache_stall_request;                            // Data cache stall request
wire   dcache_stall_request;
output dcache_refilling;
wire   dcache_refilling;


output [(32-1):0] load_data_w;                    // Result of a load instruction
reg    [(32-1):0] load_data_w;
output stall_wb_load;                                   // Request to stall pipeline due to a load from the Wishbone interface
reg    stall_wb_load;

output dtlb_stall_request;                              // Data TLB stall request
wire   dtlb_stall_request;
output [(32-1):0] dtlb_miss_vfn;                  // Virtual frame number of missed load or store address
wire   [(32-1):0] dtlb_miss_vfn;
output dtlb_miss_x;                                     // Indicates if a data TLB miss has occured
wire   dtlb_miss_x;
output dtlb_fault_x;                                    // Indicates if a data TLB fault has occured in X stage
wire   dtlb_fault_x;

output [(32-1):0] d_dat_o;                        // Data Wishbone interface write data
reg    [(32-1):0] d_dat_o;
output [(32-1):0] d_adr_o;                        // Data Wishbone interface address
reg    [(32-1):0] d_adr_o;
output d_cyc_o;                                         // Data Wishbone interface cycle
reg    d_cyc_o;
output [(4-1):0] d_sel_o;                 // Data Wishbone interface byte select
reg    [(4-1):0] d_sel_o;
output d_stb_o;                                         // Data Wishbone interface strobe
reg    d_stb_o;
output d_we_o;                                          // Data Wishbone interface write enable
reg    d_we_o;
output [(3-1):0] d_cti_o;                       // Data Wishbone interface cycle type
reg    [(3-1):0] d_cti_o;
output d_lock_o;                                        // Date Wishbone interface lock bus
reg    d_lock_o;
output [(2-1):0] d_bte_o;                       // Data Wishbone interface burst type
wire   [(2-1):0] d_bte_o;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

// Microcode pipeline registers - See inputs for description
reg [1:0] size_m;
reg [1:0] size_w;
reg sign_extend_m;
reg sign_extend_w;
reg [(32-1):0] store_data_x;
reg [(32-1):0] store_data_m;
reg [(4-1):0] byte_enable_x;
reg [(4-1):0] byte_enable_m;
wire [(32-1):0] data_m;
reg [(32-1):0] data_w;

wire dcache_select_x;                                   // Select data cache to load from / store to
reg dcache_select_m;
wire [(32-1):0] dcache_data_m;                    // Data read from cache
wire [(32-1):0] dcache_refill_address;            // Address to refill data cache from
reg dcache_refill_ready;                                // Indicates the next word of refill data is ready
wire [(3-1):0] first_cycle_type;                // First Wishbone cycle type
wire [(3-1):0] next_cycle_type;                 // Next Wishbone cycle type
wire last_word;                                         // Indicates if this is the last word in the cache line
wire [(32-1):0] first_address;                    // First cache refill address
wire wb_select_x;                                       // Select Wishbone to load from / store to
reg wb_select_m;
reg [(32-1):0] wb_data_m;                         // Data read from Wishbone
reg wb_load_complete;                                   // Indicates when a Wishbone load is complete
wire [(32-1):0] physical_load_store_address_m;    // X stage physical load/store address
wire cache_inhibit_x;                                   // Indicates if data cache should be bypassed

/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Instantiations
/////////////////////////////////////////////////////


// Data cache
lm32_dcache #(
    .associativity          (associativity),
    .sets                   (sets),
    .bytes_per_line         (bytes_per_line),
    .base_address           (base_address),
    .limit                  (limit)
    ) dcache (
    // ----- Inputs -----
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .stall_a                (stall_a),
    .stall_x                (stall_x),
    .stall_m                (stall_m),
    .address_x              (load_store_address_x),
    /* VIPT cache, address_m is (only) used for tag */
    .address_m              (physical_load_store_address_m),
    .load_q_m               (load_q_m & dcache_select_m),
    .store_q_m              (store_q_m & dcache_select_m),
    .store_data             (store_data_m),
    .store_byte_select      (byte_enable_m & {4{dcache_select_m}}),
    .refill_ready           (dcache_refill_ready),
    .refill_data            (wb_data_m),
    .dflush                 (dflush),
    .dtlb_miss_x            (dtlb_miss_x),
    // ----- Outputs -----
    .stall_request          (dcache_stall_request),
    .restart_request        (dcache_restart_request),
    .refill_request         (dcache_refill_request),
    .refill_address         (dcache_refill_address),
    .refilling              (dcache_refilling),
    .load_data              (dcache_data_m)
    );

// Data TLB
lm32_dtlb dtlb (
    // ----- Inputs -----
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .enable                 (dtlb_enable),
    .stall_x                (stall_x),
    .stall_m                (stall_m),
    .address_x              (load_store_address_x),
    .address_m              (load_store_address_m),
    .load_d                 (load_d),
    .store_d                (store_d),
    .load_q_x               (load_q_x),
    .store_q_x              (store_q_x),
    .tlbpaddr               (tlbpaddr),
    .tlbvaddr               (tlbvaddr),
    .update                 (dtlb_update),
    .flush                  (dtlb_flush),
    .invalidate             (dtlb_invalidate),
    // ----- Outputs -----
    .physical_load_store_address_m (physical_load_store_address_m),
    .stall_request          (dtlb_stall_request),
    .miss_vfn               (dtlb_miss_vfn),
    .miss_x                 (dtlb_miss_x),
    .fault_x                (dtlb_fault_x),
    .cache_inhibit_x        (cache_inhibit_x)
    );

/////////////////////////////////////////////////////
// Combinational Logic
/////////////////////////////////////////////////////

// Select where data should be loaded from / stored to


   assign dcache_select_x =    (load_store_address_x >= 32'h0)
                            && (load_store_address_x <= 32'h7fffffff)
                            && (cache_inhibit_x == 1'b0)
                     ;

   assign wb_select_x =    1'b1
                        && !dcache_select_x
                     ;

// Make sure data to store is in correct byte lane
always @(*)
begin
    case (size_x)
    2'b00:  store_data_x = {4{store_operand_x[7:0]}};
    2'b11: store_data_x = {2{store_operand_x[15:0]}};
    2'b10:  store_data_x = store_operand_x;
    default:          store_data_x = {32{1'bx}};
    endcase
end

// Generate byte enable accoring to size of load or store and address being accessed
always @(*)
begin
    casez ({size_x, load_store_address_x[1:0]})
    {2'b00, 2'b11}:  byte_enable_x = 4'b0001;
    {2'b00, 2'b10}:  byte_enable_x = 4'b0010;
    {2'b00, 2'b01}:  byte_enable_x = 4'b0100;
    {2'b00, 2'b00}:  byte_enable_x = 4'b1000;
    {2'b11, 2'b1?}: byte_enable_x = 4'b0011;
    {2'b11, 2'b0?}: byte_enable_x = 4'b1100;
    {2'b10, 2'b??}:  byte_enable_x = 4'b1111;
    default:                   byte_enable_x = 4'bxxxx;
    endcase
end




      // WB + DC
   assign data_m = wb_select_m == 1'b1
                   ? wb_data_m
                   : dcache_data_m;
   
// Sub-word selection and sign/zero-extension for loads
always @(*)
begin
    casez ({size_w, load_store_address_w[1:0]})
    {2'b00, 2'b11}:  load_data_w = {{24{sign_extend_w & data_w[7]}}, data_w[7:0]};
    {2'b00, 2'b10}:  load_data_w = {{24{sign_extend_w & data_w[15]}}, data_w[15:8]};
    {2'b00, 2'b01}:  load_data_w = {{24{sign_extend_w & data_w[23]}}, data_w[23:16]};
    {2'b00, 2'b00}:  load_data_w = {{24{sign_extend_w & data_w[31]}}, data_w[31:24]};
    {2'b11, 2'b1?}: load_data_w = {{16{sign_extend_w & data_w[15]}}, data_w[15:0]};
    {2'b11, 2'b0?}: load_data_w = {{16{sign_extend_w & data_w[31]}}, data_w[31:16]};
    {2'b10, 2'b??}:  load_data_w = data_w;
    default:                   load_data_w = {32{1'bx}};
    endcase
end

// Unused/constant Wishbone signals
assign d_bte_o = 2'b00;

// Generate signal to indicate last word in cache line
generate
    case (bytes_per_line)
    4:
    begin
assign first_cycle_type = 3'b111;
assign next_cycle_type = 3'b111;
assign last_word = 1'b1;
assign first_address = {dcache_refill_address[32-1:2], 2'b00};
    end
    8:
    begin
assign first_cycle_type = 3'b010;
assign next_cycle_type = 3'b111;
assign last_word = (&d_adr_o[addr_offset_msb:addr_offset_lsb]) == 1'b1;
assign first_address = {dcache_refill_address[32-1:addr_offset_msb+1], {addr_offset_width{1'b0}}, 2'b00};
    end
    default:
    begin
assign first_cycle_type = 3'b010;
assign next_cycle_type = d_adr_o[addr_offset_msb:addr_offset_lsb+1] == {addr_offset_width-1{1'b1}} ? 3'b111 : 3'b010;
assign last_word = (&d_adr_o[addr_offset_msb:addr_offset_lsb]) == 1'b1;
assign first_address = {dcache_refill_address[32-1:addr_offset_msb+1], {addr_offset_width{1'b0}}, 2'b00};
    end
    endcase
endgenerate

/////////////////////////////////////////////////////
// Sequential Logic
/////////////////////////////////////////////////////

// Data Wishbone interface
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        d_cyc_o <= 1'b0;
        d_stb_o <= 1'b0;
        d_dat_o <= {32{1'b0}};
        d_adr_o <= {32{1'b0}};
        d_sel_o <= {4{1'b0}};
        d_we_o <= 1'b0;
        d_cti_o <= 3'b111;
        d_lock_o <= 1'b0;
        wb_data_m <= {32{1'b0}};
        wb_load_complete <= 1'b0;
        stall_wb_load <= 1'b0;
        dcache_refill_ready <= 1'b0;
    end
    else
    begin
        // Refill ready should only be asserted for a single cycle
        dcache_refill_ready <= 1'b0;
        // Is a Wishbone cycle already in progress?
        if (d_cyc_o == 1'b1)
        begin
            // Is the cycle complete?
            if ((d_ack_i == 1'b1) || (d_err_i == 1'b1))
            begin
                if ((dcache_refilling == 1'b1) && (!last_word))
                begin
                    // Fetch next word of cache line
                    d_adr_o[addr_offset_msb:addr_offset_lsb] <= d_adr_o[addr_offset_msb:addr_offset_lsb] + 1'b1;
                end
                else
                begin
                    // Refill/access complete
                    d_cyc_o <= 1'b0;
                    d_stb_o <= 1'b0;
                    d_lock_o <= 1'b0;
                end
                d_cti_o <= next_cycle_type;
                // If we are performing a refill, indicate to cache next word of data is ready
                dcache_refill_ready <= dcache_refilling;
                // Register data read from Wishbone interface
                wb_data_m <= d_dat_i;
                // Don't set when stores complete - otherwise we'll deadlock if load in m stage
                wb_load_complete <= !d_we_o;
            end
            // synthesis translate_off
            if (d_err_i == 1'b1)
                $display ("Data bus error. Address: %x", d_adr_o);
            // synthesis translate_on
        end
        else
        begin
            if (dcache_refill_request == 1'b1)
            begin
                // Start cache refill
                d_adr_o <= first_address;
                d_cyc_o <= 1'b1;
                d_sel_o <= {32/8{1'b1}};
                d_stb_o <= 1'b1;
                d_we_o <= 1'b0;
                d_cti_o <= first_cycle_type;
                //d_lock_o <= `TRUE;
            end
            else
                 if (   (store_q_m == 1'b1)
                     && (stall_m == 1'b0)
                    )
            begin
                // Data cache is write through, so all stores go to memory
                d_dat_o <= store_data_m;
                d_adr_o <=
                    (dtlb_enable) ? physical_load_store_address_m :
                    load_store_address_m;
                d_cyc_o <= 1'b1;
                d_sel_o <= byte_enable_m;
                d_stb_o <= 1'b1;
                d_we_o <= 1'b1;
                d_cti_o <= 3'b111;
            end
            else if (   (load_q_m == 1'b1)
                     && (wb_select_m == 1'b1)
                     && (wb_load_complete == 1'b0)
                     // stall_m will be TRUE, because stall_wb_load will be TRUE
                    )
            begin
                // Read requested address
                stall_wb_load <= 1'b0;
                d_adr_o <=
                    (dtlb_enable) ? physical_load_store_address_m :
                    load_store_address_m;
                d_cyc_o <= 1'b1;
                d_sel_o <= byte_enable_m;
                d_stb_o <= 1'b1;
                d_we_o <= 1'b0;
                d_cti_o <= 3'b111;
            end
        end
        // Clear load/store complete flag when instruction leaves M stage
        if (stall_m == 1'b0)
            wb_load_complete <= 1'b0;
        // When a Wishbone load first enters the M stage, we need to stall it
        if ((load_q_x == 1'b1) && (wb_select_x == 1'b1) && (stall_x == 1'b0))
            stall_wb_load <= 1'b1;
        // Clear stall request if load instruction is killed
        if ((kill_m == 1'b1) || (exception_m == 1'b1))
            stall_wb_load <= 1'b0;
    end
end

// Pipeline registers

// X/M stage pipeline registers
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        sign_extend_m <= 1'b0;
        size_m <= 2'b00;
        byte_enable_m <= 1'b0;
        store_data_m <= {32{1'b0}};
        dcache_select_m <= 1'b0;
        wb_select_m <= 1'b0;
    end
    else
    begin
        if (stall_m == 1'b0)
        begin
            sign_extend_m <= sign_extend_x;
            size_m <= size_x;
            byte_enable_m <= byte_enable_x;
            store_data_m <= store_data_x;
            dcache_select_m <= dcache_select_x;
            wb_select_m <= wb_select_x;
        end
    end
end

// M/W stage pipeline registers
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        size_w <= 2'b00;
        data_w <= {32{1'b0}};
        sign_extend_w <= 1'b0;
    end
    else
    begin
        size_w <= size_m;
        data_w <= data_m;
        sign_extend_w <= sign_extend_m;
    end
end

/////////////////////////////////////////////////////
// Behavioural Logic
/////////////////////////////////////////////////////

// synthesis translate_off

// Check for non-aligned loads or stores
always @(posedge clk_i)
begin
    if (((load_q_m == 1'b1) || (store_q_m == 1'b1)) && (stall_m == 1'b0))
    begin
        if ((size_m === 2'b11) && (load_store_address_m[0] !== 1'b0))
            $display ("Warning: Non-aligned halfword access. Address: 0x%0x Time: %0t.", load_store_address_m, $time);
        if ((size_m === 2'b10) && (load_store_address_m[1:0] !== 2'b00))
            $display ("Warning: Non-aligned word access. Address: 0x%0x Time: %0t.", load_store_address_m, $time);
    end
end

// synthesis translate_on

endmodule  