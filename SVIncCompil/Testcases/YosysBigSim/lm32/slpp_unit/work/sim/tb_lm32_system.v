/*
 * LatticeMico32
 * System Test Bench
 *
 * Copyright (c) 2012 Michael Walle <michael@walle.cc>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types

`timescale 1 ns / 1 ps

module testbench();

integer i;

reg sys_rst;
reg sys_clk;
reg [31:0] interrupt;

reg i_ack;
wire [31:0] i_adr;
wire i_cyc;
wire [31:0] i_dat;
wire i_stb;

reg d_ack;
wire [31:0] d_adr;
wire d_cyc;
wire [31:0] d_dat_i;
wire [31:0] d_dat_o;
wire [3:0] d_sel;
wire d_stb;

lm32_top lm32(
	.clk_i(sys_clk),
	.rst_i(sys_rst),

	.interrupt(interrupt),
	.ext_break(1'b0),

	.I_ACK_I(i_ack),
	.I_ADR_O(i_adr),
	.I_BTE_O(),
	.I_CTI_O(),
	.I_CYC_O(i_cyc),
	.I_DAT_I(i_dat),
	.I_DAT_O(),
	.I_ERR_I(1'b0),
	.I_LOCK_O(),
	.I_RTY_I(1'b0),
	.I_SEL_O(),
	.I_STB_O(i_stb),
	.I_WE_O(),

	.D_ACK_I(d_ack),
	.D_ADR_O(d_adr),
	.D_BTE_O(),
	.D_CTI_O(),
	.D_CYC_O(d_cyc),
	.D_DAT_I(d_dat_i),
	.D_DAT_O(d_dat_o),
	.D_ERR_I(1'b0),
	.D_LOCK_O(),
	.D_RTY_I(1'b0),
	.D_SEL_O(d_sel),
	.D_STB_O(d_stb),
	.D_WE_O(d_we)
);

// clock
initial sys_clk = 1'b0;
always #50 sys_clk = ~sys_clk;

// reset
initial begin
	sys_rst = 1'b0;
	repeat (500) @(posedge sys_clk);
	sys_rst = 1'b1;
	repeat (500) @(posedge sys_clk);
	sys_rst = 1'b0;
end

// memory
reg [7:0] mem[0:65535];
initial begin
	for(i=0;i<65536;i=i+1)
		mem[i] = 8'b0;
end

// memory monitor bitmap
reg mem_monitor_prog_rd[0:'h4000];
reg mem_monitor_data_rd[0:'h4000];
reg mem_monitor_data_wr[0:'h4000];
initial begin
	for(i=0;i<'h4000;i=i+1) begin
		// print prog read (until icache is hot) and non-stack data writes
		mem_monitor_prog_rd[i] = 1;
		mem_monitor_data_rd[i] = 0;
		mem_monitor_data_wr[i] = i < 'h3000;
	end
end

wire [31:0] dmem_dat_i;
reg [31:0] dmem_dat_o;
wire [13:0] dmem_adr;
wire [3:0] dmem_we;
always @(posedge sys_clk) begin
	if(dmem_we[0]) mem[{dmem_adr, 2'b11}] <= dmem_dat_i[7:0];
	if(dmem_we[1]) mem[{dmem_adr, 2'b10}] <= dmem_dat_i[15:8];
	if(dmem_we[2]) mem[{dmem_adr, 2'b01}] <= dmem_dat_i[23:16];
	if(dmem_we[3]) mem[{dmem_adr, 2'b00}] <= dmem_dat_i[31:24];
	dmem_dat_o[7:0]   <= mem[{dmem_adr, 2'b11}];
	dmem_dat_o[15:8]  <= mem[{dmem_adr, 2'b10}];
	dmem_dat_o[23:16] <= mem[{dmem_adr, 2'b01}];
	dmem_dat_o[31:24] <= mem[{dmem_adr, 2'b00}];

	if (dmem_we) begin
		if (mem_monitor_data_wr[dmem_adr] && !d_ack)
			$display("DATA WR: @%08x %02x%02x%02x%02x (%b)", {dmem_adr, 2'b00},
					dmem_we[3] ? dmem_dat_i[31:24] : 8'bz,
					dmem_we[2] ? dmem_dat_i[23:16] : 8'bz,
					dmem_we[1] ? dmem_dat_i[15: 8] : 8'bz,
					dmem_we[0] ? dmem_dat_i[ 7: 0] : 8'bz, dmem_we);
	end else if (d_cyc) begin
		if (mem_monitor_data_rd[dmem_adr] && !d_ack)
			$display("DATA RD: @%08x %02x%02x%02x%02x", {dmem_adr, 2'b00}, 
					mem[{dmem_adr, 2'b00}], mem[{dmem_adr, 2'b01}],
					mem[{dmem_adr, 2'b10}], mem[{dmem_adr, 2'b11}]);
	end
end
reg [31:0] pmem_dat_o;
wire [13:0] pmem_adr;
always @(posedge sys_clk) begin
	pmem_dat_o[7:0]   <= mem[{pmem_adr, 2'b11}];
	pmem_dat_o[15:8]  <= mem[{pmem_adr, 2'b10}];
	pmem_dat_o[23:16] <= mem[{pmem_adr, 2'b01}];
	pmem_dat_o[31:24] <= mem[{pmem_adr, 2'b00}];

	if (i_cyc && !i_ack && mem_monitor_prog_rd[pmem_adr])
		$display("PROG RD: @%08x %02x%02x%02x%02x", {pmem_adr, 2'b00}, 
				mem[{pmem_adr, 2'b00}], mem[{pmem_adr, 2'b01}],
				mem[{pmem_adr, 2'b10}], mem[{pmem_adr, 2'b11}]);
end

// uart
always @(posedge sys_clk) begin
	if(d_cyc & d_stb & d_we & d_ack) begin
		if(d_adr == 32'hff000000)
			$write("%c", d_dat_o[7:0]);
		if(d_adr == 32'hff000004)
			$display("OUT: %d", d_dat_o);
	end
end

// wishbone interface for instruction bus
always @(posedge sys_clk) begin
	if(sys_rst)
		i_ack <= 1'b0;
	else begin
		i_ack <= 1'b0;
		if(i_cyc & i_stb & ~i_ack)
			i_ack <= 1'b1;
	end
end

integer clock_counter = 0;
always @(posedge sys_clk) begin
	clock_counter = clock_counter + 1;
	if (clock_counter == 1000) begin
		$display("-- 1000 sys_clk cycles --");
		clock_counter = 0;
	end
end

assign i_dat = pmem_dat_o;
assign pmem_adr = i_adr[15:2];


// wishbone interface for data bus
always @(posedge sys_clk) begin
	if(sys_rst)
		d_ack <= 1'b0;
	else begin
		d_ack <= 1'b0;
		if(d_cyc & d_stb & ~d_ack)
			d_ack <= 1'b1;
	end
end

assign d_dat_i = dmem_dat_o;
assign dmem_dat_i = d_dat_o;
assign dmem_adr = d_adr[15:2];
assign dmem_we = {4{d_cyc & d_stb & d_we & ~|d_adr[31:16]}} & d_sel;

// interrupts
initial interrupt <= 32'b0;

// simulation end request
always @(posedge sys_clk) begin
	if(d_cyc & d_stb & d_we & d_ack)
		if(d_adr == 32'hdead0000 && d_dat_o == 32'hbeef)
			$finish;
end

// traces


// dump signals
reg [256*8:0] vcdfile;
initial begin
	if($value$plusargs("dump=%s", vcdfile)) begin
		$dumpfile(vcdfile);
		$dumpvars(0, testbench);
	end
end

// init memory
reg [256*8:0] prog;
initial begin
	if(! $value$plusargs("prog=%s", prog)) begin
		// $display("ERROR: please specify +prog=<file>.vh to start.");
		// $finish;
		prog = "lm32/sim/sieve.vh";
	end
end

initial $readmemh(prog, mem);

// trace pipeline

initial begin
	// $dumpfile("bench.vcd");
	// @(posedge sys_rst);
	// repeat (5) @(posedge sys_clk);
	// $dumpvars(0, testbench);
	// repeat (2500) @(posedge sys_clk);
	// $finish;
end

endmodule
