//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   Copyright (c) 2011-2012 Yann Sionneau <yann.sionneau@gmail.com>
//   Copyright (c) 2012 Michael Walle <michael@walle.cc>
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_cpu.v
// Title            : Top-level of CPU.
// Dependencies     : lm32_include.v
//
// Version 3.8
// 1. Feature: Support for dynamically switching EBA to DEBA via a GPIO.
// 2. Bug: EA now reports instruction that caused the data abort, rather than
//    next instruction.
//
// Version 3.4
// 1. Bug Fix: In a tight infinite loop (add, sw, bi) incoming interrupts were
//    never serviced.
//
// Version 3.3
// 1. Feature: Support for memory that is tightly coupled to processor core, and
//    has a single-cycle access latency (same as caches). Instruction port has
//    access to a dedicated physically-mapped memory. Data port has access to
//    a dedicated physically-mapped memory. In order to be able to manipulate
//    values in both these memories via the debugger, these memories also
//    interface with the data port of LM32.
// 2. Feature: Extended Configuration Register
// 3. Bug Fix: Removed port names that conflict with keywords reserved in System-
//    Verilog.
//
// Version 3.2
// 1. Bug Fix: Single-stepping a load/store to invalid address causes debugger to
//    hang. At the same time CPU fails to register data bus error exception. Bug
//    is caused because (a) data bus error exception occurs after load/store has
//    passed X stage and next sequential instruction (e.g., brk) is already in X
//    stage, and (b) data bus error exception had lower priority than, say, brk
//    exception.
// 2. Bug Fix: If a brk (or scall/eret/bret) sequentially follows a load/store to
//    invalid location, CPU will fail to register data bus error exception. The
//    solution is to stall scall/eret/bret/brk instructions in D pipeline stage
//    until load/store has completed.
// 3. Feature: Enable precise identification of load/store that causes seg fault.
// 4. SYNC resets used for register file when implemented in EBRs.
//
// Version 3.1
// 1. Feature: LM32 Register File can now be mapped in to on-chip block RAM (EBR)
//    instead of distributed memory by enabling the option in LM32 GUI.
// 2. Feature: LM32 also adds a static branch predictor to improve branch
//    performance. All immediate-based forward-pointing branches are predicted
//    not-taken. All immediate-based backward-pointing branches are predicted taken.
//
// Version 7.0SP2, 3.0
// No Change
//
// Version 6.1.17
// Initial Release
// =============================================================================

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types


/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_cpu (  
    // ----- Inputs -------
    clk_i,
    rst_i,
    // From external devices
    interrupt,
    // From user logic
    ext_break,
    // Instruction Wishbone master
    I_DAT_I,
    I_ACK_I,
    I_ERR_I,
    I_RTY_I,
    // Data Wishbone master
    D_DAT_I,
    D_ACK_I,
    D_ERR_I,
    D_RTY_I,
    // ----- Outputs -------
    // Instruction Wishbone master
    I_DAT_O,
    I_ADR_O,
    I_CYC_O,
    I_SEL_O,
    I_STB_O,
    I_WE_O,
    I_CTI_O,
    I_LOCK_O,
    I_BTE_O,
    // Data Wishbone master
    D_DAT_O,
    D_ADR_O,
    D_CYC_O,
    D_SEL_O,
    D_STB_O,
    D_WE_O,
    D_CTI_O,
    D_LOCK_O,
    D_BTE_O
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter eba_reset = 32'h0;                           // Reset value for EBA CSR
parameter deba_reset = 32'h0;                         // Reset value for DEBA CSR

parameter icache_associativity = 1;     // Associativity of the cache (Number of ways)
parameter icache_sets = 256;                       // Number of sets
parameter icache_bytes_per_line = 16;   // Number of bytes per cache line
parameter icache_base_address = 32'h0;       // Base address of cachable memory
parameter icache_limit = 32'h7fffffff;                     // Limit (highest address) of cachable memory

parameter dcache_associativity = 1;     // Associativity of the cache (Number of ways)
parameter dcache_sets = 256;                       // Number of sets
parameter dcache_bytes_per_line = 16;   // Number of bytes per cache line
parameter dcache_base_address = 32'h0;       // Base address of cachable memory
parameter dcache_limit = 32'h7fffffff;                     // Limit (highest address) of cachable memory

parameter watchpoints = 32'h4;                       // Number of h/w watchpoint CSRs
parameter breakpoints = 32'h4;                       // Number of h/w breakpoint CSRs

parameter interrupts = 32;                         // Number of interrupts

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_i;                                    // Clock
input rst_i;                                    // Reset


input [(32-1):0] interrupt;          // Interrupt pins



input [(32-1):0] I_DAT_I;                 // Instruction Wishbone interface read data
input I_ACK_I;                                  // Instruction Wishbone interface acknowledgement
input I_ERR_I;                                  // Instruction Wishbone interface error
input I_RTY_I;                                  // Instruction Wishbone interface retry

input [(32-1):0] D_DAT_I;                 // Data Wishbone interface read data
input D_ACK_I;                                  // Data Wishbone interface acknowledgement
input D_ERR_I;                                  // Data Wishbone interface error
input D_RTY_I;                                  // Data Wishbone interface retry

input ext_break;

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////




output [(32-1):0] I_DAT_O;                // Instruction Wishbone interface write data
wire   [(32-1):0] I_DAT_O;
output [(32-1):0] I_ADR_O;                // Instruction Wishbone interface address
wire   [(32-1):0] I_ADR_O;
output I_CYC_O;                                 // Instruction Wishbone interface cycle
wire   I_CYC_O;
output [(4-1):0] I_SEL_O;         // Instruction Wishbone interface byte select
wire   [(4-1):0] I_SEL_O;
output I_STB_O;                                 // Instruction Wishbone interface strobe
wire   I_STB_O;
output I_WE_O;                                  // Instruction Wishbone interface write enable
wire   I_WE_O;
output [(3-1):0] I_CTI_O;               // Instruction Wishbone interface cycle type
wire   [(3-1):0] I_CTI_O;
output I_LOCK_O;                                // Instruction Wishbone interface lock bus
wire   I_LOCK_O;
output [(2-1):0] I_BTE_O;               // Instruction Wishbone interface burst type
wire   [(2-1):0] I_BTE_O;

output [(32-1):0] D_DAT_O;                // Data Wishbone interface write data
wire   [(32-1):0] D_DAT_O;
output [(32-1):0] D_ADR_O;                // Data Wishbone interface address
wire   [(32-1):0] D_ADR_O;
output D_CYC_O;                                 // Data Wishbone interface cycle
wire   D_CYC_O;
output [(4-1):0] D_SEL_O;         // Data Wishbone interface byte select
wire   [(4-1):0] D_SEL_O;
output D_STB_O;                                 // Data Wishbone interface strobe
wire   D_STB_O;
output D_WE_O;                                  // Data Wishbone interface write enable
wire   D_WE_O;
output [(3-1):0] D_CTI_O;               // Data Wishbone interface cycle type
wire   [(3-1):0] D_CTI_O;
output D_LOCK_O;                                // Date Wishbone interface lock bus
wire   D_LOCK_O;
output [(2-1):0] D_BTE_O;               // Data Wishbone interface burst type
wire   [(2-1):0] D_BTE_O;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

// Pipeline registers

reg valid_a;                                    // Instruction in A stage is valid
reg valid_f;                                    // Instruction in F stage is valid
reg valid_d;                                    // Instruction in D stage is valid
reg valid_x;                                    // Instruction in X stage is valid
reg valid_m;                                    // Instruction in M stage is valid
reg valid_w;                                    // Instruction in W stage is valid

wire q_x;
wire [(32-1):0] immediate_d;              // Immediate operand
wire load_d;                                    // Indicates a load instruction
reg load_x;
reg load_m;
wire load_q_x;
wire store_q_x;
wire store_d;                                   // Indicates a store instruction
reg store_x;
reg store_m;
wire [1:0] size_d;                   // Size of load/store (byte, hword, word)
reg [1:0] size_x;
wire branch_d;                                  // Indicates a branch instruction
wire branch_predict_d;                          // Indicates a branch is predicted
wire branch_predict_taken_d;                    // Indicates a branch is predicted taken
wire [((32-2)+2-1):2] branch_predict_address_d;   // Address to which predicted branch jumps
wire [((32-2)+2-1):2] branch_target_d;
wire bi_unconditional;
wire bi_conditional;
reg branch_x;
reg branch_predict_x;
reg branch_predict_taken_x;
reg branch_m;
reg branch_predict_m;
reg branch_predict_taken_m;
wire branch_mispredict_taken_m;                 // Indicates a branch was mispredicted as taken
wire branch_flushX_m;                           // Indicates that instruction in X stage must be squashed
wire branch_reg_d;                              // Branch to register or immediate
wire [((32-2)+2-1):2] branch_offset_d;            // Branch offset for immediate branches
reg [((32-2)+2-1):2] branch_target_x;             // Address to branch to
reg [((32-2)+2-1):2] branch_target_m;
wire [0:0] d_result_sel_0_d; // Which result should be selected in D stage for operand 0
wire [1:0] d_result_sel_1_d; // Which result should be selected in D stage for operand 1

wire x_result_sel_csr_d;                        // Select X stage result from CSRs
reg x_result_sel_csr_x;
wire x_result_sel_mc_arith_d;                   // Select X stage result from multi-cycle arithmetic unit
reg x_result_sel_mc_arith_x;
wire x_result_sel_sext_d;                       // Select X stage result from sign-extend logic
reg x_result_sel_sext_x;
wire x_result_sel_logic_d;                      // Select X stage result from logic op unit
reg x_result_sel_logic_x;
wire x_result_sel_add_d;                        // Select X stage result from adder
reg x_result_sel_add_x;
wire m_result_sel_compare_d;                    // Select M stage result from comparison logic
reg m_result_sel_compare_x;
reg m_result_sel_compare_m;
wire m_result_sel_shift_d;                      // Select M stage result from shifter
reg m_result_sel_shift_x;
reg m_result_sel_shift_m;
wire w_result_sel_load_d;                       // Select W stage result from load/store unit
reg w_result_sel_load_x;
reg w_result_sel_load_m;
reg w_result_sel_load_w;
wire w_result_sel_mul_d;                        // Select W stage result from multiplier
reg w_result_sel_mul_x;
reg w_result_sel_mul_m;
reg w_result_sel_mul_w;
wire x_bypass_enable_d;                         // Whether result is bypassable in X stage
reg x_bypass_enable_x;
wire m_bypass_enable_d;                         // Whether result is bypassable in M stage
reg m_bypass_enable_x;
reg m_bypass_enable_m;
wire sign_extend_d;                             // Whether to sign-extend or zero-extend
reg sign_extend_x;
wire write_enable_d;                            // Register file write enable
reg write_enable_x;
wire write_enable_q_x;
reg write_enable_m;
wire write_enable_q_m;
reg write_enable_w;
wire write_enable_q_w;
wire read_enable_0_d;                           // Register file read enable 0
wire [(5-1):0] read_idx_0_d;          // Register file read index 0
wire read_enable_1_d;                           // Register file read enable 1
wire [(5-1):0] read_idx_1_d;          // Register file read index 1
wire [(5-1):0] write_idx_d;           // Register file write index
reg [(5-1):0] write_idx_x;
reg [(5-1):0] write_idx_m;
reg [(5-1):0] write_idx_w;
wire [(5-1):0] csr_d;                     // CSR read/write index
reg  [(5-1):0] csr_x;
wire [(3-1):0] condition_d;         // Branch condition
reg [(3-1):0] condition_x;
wire break_d;                                   // Indicates a break instruction
reg break_x;
wire scall_d;                                   // Indicates a scall instruction
reg scall_x;
wire eret_d;                                    // Indicates an eret instruction
reg eret_x;
wire eret_q_x;
wire eret_k_q_x;
reg eret_m;
wire bret_d;                                    // Indicates a bret instruction
reg bret_x;
wire bret_q_x;
wire bret_k_q_x;
reg bret_m;
wire csr_write_enable_d;                        // CSR write enable
reg csr_write_enable_x;
wire csr_write_enable_q_x;
wire csr_write_enable_k_q_x;

wire bus_error_d;                               // Indicates an bus error occured while fetching the instruction in this pipeline stage
reg bus_error_x;
reg data_bus_error_exception_m;
reg [((32-2)+2-1):2] memop_pc_w;

reg [(32-1):0] d_result_0;                // Result of instruction in D stage (operand 0)
reg [(32-1):0] d_result_1;                // Result of instruction in D stage (operand 1)
reg [(32-1):0] x_result;                  // Result of instruction in X stage
reg [(32-1):0] m_result;                  // Result of instruction in M stage
reg [(32-1):0] w_result;                  // Result of instruction in W stage

reg [(32-1):0] operand_0_x;               // Operand 0 for X stage instruction
reg [(32-1):0] operand_1_x;               // Operand 1 for X stage instruction
reg [(32-1):0] store_operand_x;           // Data read from register to store
reg [(32-1):0] operand_m;                 // Operand for M stage instruction
reg [(32-1):0] operand_w;                 // Operand for W stage instruction

// To/from register file
reg [(32-1):0] reg_data_live_0;
reg [(32-1):0] reg_data_live_1;
reg use_buf;                                    // Whether to use reg_data_live or reg_data_buf
reg [(32-1):0] reg_data_buf_0;
reg [(32-1):0] reg_data_buf_1;
wire [(32-1):0] reg_data_0;               // Register file read port 0 data
wire [(32-1):0] reg_data_1;               // Register file read port 1 data
reg [(32-1):0] bypass_data_0;             // Register value 0 after bypassing
reg [(32-1):0] bypass_data_1;             // Register value 1 after bypassing
wire reg_write_enable_q_w;

reg interlock;                                  // Indicates pipeline should be stalled because of a read-after-write hazzard

wire stall_a;                                   // Stall instruction in A pipeline stage
wire stall_f;                                   // Stall instruction in F pipeline stage
wire stall_d;                                   // Stall instruction in D pipeline stage
wire stall_x;                                   // Stall instruction in X pipeline stage
wire stall_m;                                   // Stall instruction in M pipeline stage

// To/from adder
wire adder_op_d;                                // Whether to add or subtract
reg adder_op_x;
reg adder_op_x_n;                               // Inverted version of adder_op_x
wire [(32-1):0] adder_result_x;           // Result from adder
wire adder_overflow_x;                          // Whether a signed overflow occured
wire adder_carry_n_x;                           // Whether a carry was generated

// To/from logical operations unit
wire [3:0] logic_op_d;           // Which operation to perform
reg [3:0] logic_op_x;
wire [(32-1):0] logic_result_x;           // Result of logical operation

// From sign-extension unit
wire [(32-1):0] sextb_result_x;           // Result of byte sign-extension
wire [(32-1):0] sexth_result_x;           // Result of half-word sign-extenstion
wire [(32-1):0] sext_result_x;            // Result of sign-extension specified by instruction

// To/from shifter
wire direction_d;                               // Which direction to shift in
reg direction_x;
wire [(32-1):0] shifter_result_m;         // Result of shifter

// To/from multiplier
wire [(32-1):0] multiplier_result_w;      // Result from multiplier

// To/from divider
wire divide_d;                                  // Indicates whether to perform a divider or not
wire divide_q_d;
wire modulus_d;
wire modulus_q_d;
wire divide_by_zero_x;                          // Indicates an attempt was made to divide by zero

// To from multi-cycle arithmetic unit
wire mc_stall_request_x;                        // Multi-cycle arithmetic unit stall request
wire [(32-1):0] mc_result_x;

// From CSRs
wire [(32-1):0] interrupt_csr_read_data_x;// Data read from interrupt CSRs
wire [(32-1):0] cfg;                      // Configuration CSR
wire [(32-1):0] cfg2;                     // Extended Configuration CSR
wire [(32-1):0] psw;                      // Processor Status Word CSR
reg [(32-1):0] csr_read_data_x;           // Data read from CSRs

// To/from instruction unit
wire [((32-2)+2-1):2] pc_f;                       // PC of instruction in F stage
wire [((32-2)+2-1):2] pc_d;                       // PC of instruction in D stage
wire [((32-2)+2-1):2] pc_x;                       // PC of instruction in X stage
wire [((32-2)+2-1):2] pc_m;                       // PC of instruction in M stage
wire [((32-2)+2-1):2] pc_w;                       // PC of instruction in W stage
wire [(32-1):0] instruction_f;     // Instruction in F stage
//pragma attribute instruction_d preserve_signal true
//pragma attribute instruction_d preserve_driver true
wire [(32-1):0] instruction_d;     // Instruction in D stage
wire iflush;                                    // Flush instruction cache
wire icache_stall_request;                      // Stall pipeline because instruction cache is busy
wire icache_restart_request;                    // Restart instruction that caused an instruction cache miss
wire icache_refill_request;                     // Request to refill instruction cache
wire icache_refilling;                          // Indicates the instruction cache is being refilled

// To/from load/store unit
wire dflush_x;                                  // Flush data cache
reg dflush_m;
wire dcache_stall_request;                      // Stall pipeline because data cache is busy
wire dcache_restart_request;                    // Restart instruction that caused a data cache miss
wire dcache_refill_request;                     // Request to refill data cache
wire dcache_refilling;                          // Indicates the data cache is being refilled
wire [(32-1):0] load_data_w;              // Result of a load instruction
wire stall_wb_load;                             // Stall pipeline because of a load via the data Wishbone interface

// To/from JTAG interface

// Hazzard detection
wire raw_x_0;                                   // RAW hazzard between instruction in X stage and read port 0
wire raw_x_1;                                   // RAW hazzard between instruction in X stage and read port 1
wire raw_m_0;                                   // RAW hazzard between instruction in M stage and read port 0
wire raw_m_1;                                   // RAW hazzard between instruction in M stage and read port 1
wire raw_w_0;                                   // RAW hazzard between instruction in W stage and read port 0
wire raw_w_1;                                   // RAW hazzard between instruction in W stage and read port 1

// Control flow
wire cmp_zero;                                  // Result of comparison is zero
wire cmp_negative;                              // Result of comparison is negative
wire cmp_overflow;                              // Comparison produced an overflow
wire cmp_carry_n;                               // Comparison produced a carry, inverted
reg condition_met_x;                            // Condition of branch instruction is met
reg condition_met_m;
wire branch_taken_m;                            // Branch is taken in M stage

wire kill_f;                                    // Kill instruction in F stage
wire kill_d;                                    // Kill instruction in D stage
wire kill_x;                                    // Kill instruction in X stage
wire kill_m;                                    // Kill instruction in M stage
wire kill_w;                                    // Kill instruction in W stage

reg [((32-2)+2-1):(4+3+2)] eba;                        // Exception Base Address (EBA) CSR
reg [((32-2)+2-1):(4+3+2)] deba;                       // Debug Exception Base Address (DEBA) CSR
reg [(4-1):0] eid_x;                      // Exception ID in X stage

wire dc_ss;                                     // Is single-step enabled
wire dc_re;                                     // Remap all exceptions
wire exception_x;                               // An exception occured in the X stage
reg exception_m;                                // An instruction that caused an exception is in the M stage
wire debug_exception_x;                         // Indicates if a debug exception has occured
reg debug_exception_m;
reg debug_exception_w;
wire debug_exception_q_w;
wire non_debug_exception_x;                     // Indicates if a non debug exception has occured
reg non_debug_exception_m;
reg non_debug_exception_w;
wire non_debug_exception_q_w;

wire interrupt_exception;                       // Indicates if an interrupt exception has occured
wire breakpoint_exception;                      // Indicates if a breakpoint exception has occured
wire watchpoint_exception;                      // Indicates if a watchpoint exception has occured
wire instruction_bus_error_exception;           // Indicates if an instruction bus error exception has occured
wire data_bus_error_exception;                  // Indicates if a data bus error exception has occured
wire divide_by_zero_exception;                  // Indicates if a divide by zero exception has occured
wire system_call_exception;                     // Indicates if a system call exception has occured

reg data_bus_error_seen;                        // Indicates if a data bus error was seen

reg ext_break_r;

reg itlbe;                                      // Instruction TLB enable
reg dtlbe;                                      // Data TLB enable
reg usr;                                        // User mode
reg eitlbe;                                     // Exception instruction enable
reg edtlbe;                                     // Exception data TLB enable
reg eusr;                                       // Exception user mode
reg bitlbe;                                     // Breakpoint instruction TLB enable
reg bdtlbe;                                     // Breakpoint data TLB enable
reg busr;                                       // Breakpoint user mode

reg itlb_invalidate;                            // Invalidate an ITLB entry
reg itlb_flush;                                 // Flush all ITLB entries
reg itlb_update;                                // Update an ITLB entry
reg dtlb_invalidate;                            // Invalidate a DTLB entry
reg dtlb_flush;                                 // Flush all DTLB entries
reg dtlb_update;                                // Update an DTLB entry
reg [(32-1):0] tlbpaddr;                  // TLBPADDR CSR
reg [(32-1):0] tlbvaddr;                  // TLBVADDR CSR
reg [(32-1):0] tlbbadvaddr;               // TLBBADVADDR CSR
wire [(32-1):0] dtlb_miss_vfn;            // VFN of the missed address
wire [(32-1):0] itlb_miss_vfn;            // VFN of the missed instruction
wire itlb_miss_x;                               // Indicates if an ITLB miss has occured in the X stage
wire itlb_stall_request;                        // Stall pipeline because instruction TLB is busy
wire dtlb_miss_x;                               // Indicates if an DTLB miss has occured in the X stage
wire dtlb_fault_x;                              // Indicates if an DTLB fault has occured in the X stage
wire dtlb_stall_request;                        // Stall pipeline because data TLB is busy

wire itlb_miss_exception;                       // Indicates if an ITLB miss exception has occured
wire itlb_exception;                            // Indicates if an ITLB exception has occured
wire dtlb_miss_exception;                       // Indicates if a DTLB miss exception has occured
wire dtlb_fault_exception;                      // Indicates if a DTLB fault exception has occured
wire dtlb_exception;                            // Indicates if a DTLB exception has occured
wire privilege_exception;                       // Indicates if a privilege exception has occured

/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Instantiations
/////////////////////////////////////////////////////

// Instruction unit
lm32_instruction_unit #(
    .eba_reset              (eba_reset),
    .associativity          (icache_associativity),
    .sets                   (icache_sets),
    .bytes_per_line         (icache_bytes_per_line),
    .base_address           (icache_base_address),
    .limit                  (icache_limit)
  ) instruction_unit (
    // ----- Inputs -------
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    // From pipeline
    .stall_a                (stall_a),
    .stall_f                (stall_f),
    .stall_d                (stall_d),
    .stall_x                (stall_x),
    .stall_m                (stall_m),
    .valid_f                (valid_f),
    .valid_d                (valid_d),
    .kill_f                 (kill_f),
    .branch_predict_taken_d (branch_predict_taken_d),
    .branch_predict_address_d (branch_predict_address_d),
    .exception_m            (exception_m),
    .branch_taken_m         (branch_taken_m),
    .branch_mispredict_taken_m (branch_mispredict_taken_m),
    .branch_target_m        (branch_target_m),
    .iflush                 (iflush),
    .dcache_restart_request (dcache_restart_request),
    .dcache_refill_request  (dcache_refill_request),
    .dcache_refilling       (dcache_refilling),
    .itlb_enable            (itlbe),
    .tlbpaddr               (tlbpaddr),
    .tlbvaddr               (tlbvaddr),
    .itlb_update            (itlb_update),
    .itlb_flush             (itlb_flush),
    .itlb_invalidate        (itlb_invalidate),
    // From Wishbone
    .i_dat_i                (I_DAT_I),
    .i_ack_i                (I_ACK_I),
    .i_err_i                (I_ERR_I),
    // ----- Outputs -------
    // To pipeline
    .pc_f                   (pc_f),
    .pc_d                   (pc_d),
    .pc_x                   (pc_x),
    .pc_m                   (pc_m),
    .pc_w                   (pc_w),
    .icache_stall_request   (icache_stall_request),
    .icache_restart_request (icache_restart_request),
    .icache_refill_request  (icache_refill_request),
    .icache_refilling       (icache_refilling),
    .itlb_stall_request     (itlb_stall_request),
    .itlb_miss_vfn          (itlb_miss_vfn),
    .itlb_miss_x            (itlb_miss_x),
    // To Wishbone
    .i_dat_o                (I_DAT_O),
    .i_adr_o                (I_ADR_O),
    .i_cyc_o                (I_CYC_O),
    .i_sel_o                (I_SEL_O),
    .i_stb_o                (I_STB_O),
    .i_we_o                 (I_WE_O),
    .i_cti_o                (I_CTI_O),
    .i_lock_o               (I_LOCK_O),
    .i_bte_o                (I_BTE_O),
    .bus_error_d            (bus_error_d),
    .instruction_f          (instruction_f),
    .instruction_d          (instruction_d)
    );

// Instruction decoder
lm32_decoder decoder (
    // ----- Inputs -------
    .instruction            (instruction_d),
    // ----- Outputs -------
    .d_result_sel_0         (d_result_sel_0_d),
    .d_result_sel_1         (d_result_sel_1_d),
    .x_result_sel_csr       (x_result_sel_csr_d),
    .x_result_sel_mc_arith  (x_result_sel_mc_arith_d),
    .x_result_sel_sext      (x_result_sel_sext_d),
    .x_result_sel_logic     (x_result_sel_logic_d),
    .x_result_sel_add       (x_result_sel_add_d),
    .m_result_sel_compare   (m_result_sel_compare_d),
    .m_result_sel_shift     (m_result_sel_shift_d),
    .w_result_sel_load      (w_result_sel_load_d),
    .w_result_sel_mul       (w_result_sel_mul_d),
    .x_bypass_enable        (x_bypass_enable_d),
    .m_bypass_enable        (m_bypass_enable_d),
    .read_enable_0          (read_enable_0_d),
    .read_idx_0             (read_idx_0_d),
    .read_enable_1          (read_enable_1_d),
    .read_idx_1             (read_idx_1_d),
    .write_enable           (write_enable_d),
    .write_idx              (write_idx_d),
    .immediate              (immediate_d),
    .branch_offset          (branch_offset_d),
    .load                   (load_d),
    .store                  (store_d),
    .size                   (size_d),
    .sign_extend            (sign_extend_d),
    .adder_op               (adder_op_d),
    .logic_op               (logic_op_d),
    .direction              (direction_d),
    .divide                 (divide_d),
    .modulus                (modulus_d),
    .branch                 (branch_d),
    .bi_unconditional       (bi_unconditional),
    .bi_conditional         (bi_conditional),
    .branch_reg             (branch_reg_d),
    .condition              (condition_d),
    .break_opcode           (break_d),
    .scall                  (scall_d),
    .eret                   (eret_d),
    .bret                   (bret_d),
    .csr_write_enable       (csr_write_enable_d)
    );

// Load/store unit
lm32_load_store_unit #(
    .associativity          (dcache_associativity),
    .sets                   (dcache_sets),
    .bytes_per_line         (dcache_bytes_per_line),
    .base_address           (dcache_base_address),
    .limit                  (dcache_limit)
  ) load_store_unit (
    // ----- Inputs -------
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    // From pipeline
    .stall_a                (stall_a),
    .stall_x                (stall_x),
    .stall_m                (stall_m),
    .kill_m                 (kill_m),
    .exception_m            (exception_m),
    .store_operand_x        (store_operand_x),
    .load_store_address_x   (adder_result_x),
    .load_store_address_m   (operand_m),
    .load_store_address_w   (operand_w[1:0]),
    .load_d                 (load_d),
    .store_d                (store_d),
    .load_x                 (load_x),
    .store_x                (store_x),
    .load_q_x               (load_q_x),
    .store_q_x              (store_q_x),
    .load_q_m               (load_q_m),
    .store_q_m              (store_q_m),
    .sign_extend_x          (sign_extend_x),
    .size_x                 (size_x),
    .dflush                 (dflush_m),
    .dtlb_enable            (dtlbe),
    .tlbpaddr               (tlbpaddr),
    .tlbvaddr               (tlbvaddr),
    .dtlb_update            (dtlb_update),
    .dtlb_flush             (dtlb_flush),
    .dtlb_invalidate        (dtlb_invalidate),
    // From Wishbone
    .d_dat_i                (D_DAT_I),
    .d_ack_i                (D_ACK_I),
    .d_err_i                (D_ERR_I),
    .d_rty_i                (D_RTY_I),
    // ----- Outputs -------
    // To pipeline
    .dcache_refill_request  (dcache_refill_request),
    .dcache_restart_request (dcache_restart_request),
    .dcache_stall_request   (dcache_stall_request),
    .dcache_refilling       (dcache_refilling),
    .load_data_w            (load_data_w),
    .stall_wb_load          (stall_wb_load),
    .dtlb_stall_request     (dtlb_stall_request),
    .dtlb_miss_vfn          (dtlb_miss_vfn),
    .dtlb_miss_x            (dtlb_miss_x),
    .dtlb_fault_x           (dtlb_fault_x),
    // To Wishbone
    .d_dat_o                (D_DAT_O),
    .d_adr_o                (D_ADR_O),
    .d_cyc_o                (D_CYC_O),
    .d_sel_o                (D_SEL_O),
    .d_stb_o                (D_STB_O),
    .d_we_o                 (D_WE_O),
    .d_cti_o                (D_CTI_O),
    .d_lock_o               (D_LOCK_O),
    .d_bte_o                (D_BTE_O)
    );

// Adder
lm32_adder adder (
    // ----- Inputs -------
    .adder_op_x             (adder_op_x),
    .adder_op_x_n           (adder_op_x_n),
    .operand_0_x            (operand_0_x),
    .operand_1_x            (operand_1_x),
    // ----- Outputs -------
    .adder_result_x         (adder_result_x),
    .adder_carry_n_x        (adder_carry_n_x),
    .adder_overflow_x       (adder_overflow_x)
    );

// Logic operations
lm32_logic_op logic_op (
    // ----- Inputs -------
    .logic_op_x             (logic_op_x),
    .operand_0_x            (operand_0_x),

    .operand_1_x            (operand_1_x),
    // ----- Outputs -------
    .logic_result_x         (logic_result_x)
    );

// Pipelined barrel-shifter
lm32_shifter shifter (
    // ----- Inputs -------
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .stall_x                (stall_x),
    .direction_x            (direction_x),
    .sign_extend_x          (sign_extend_x),
    .operand_0_x            (operand_0_x),
    .operand_1_x            (operand_1_x),
    // ----- Outputs -------
    .shifter_result_m       (shifter_result_m)
    );

// Pipeline fixed-point multiplier
lm32_multiplier multiplier (
    // ----- Inputs -------
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .stall_x                (stall_x),
    .stall_m                (stall_m),
    .operand_0              (d_result_0),
    .operand_1              (d_result_1),
    // ----- Outputs -------
    .result                 (multiplier_result_w)
    );

// Multi-cycle arithmetic
lm32_mc_arithmetic mc_arithmetic (
    // ----- Inputs -------
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .stall_d                (stall_d),
    .kill_x                 (kill_x),
    .divide_d               (divide_q_d),
    .modulus_d              (modulus_q_d),
    .operand_0_d            (d_result_0),
    .operand_1_d            (d_result_1),
    // ----- Outputs -------
    .result_x               (mc_result_x),
    .divide_by_zero_x       (divide_by_zero_x),
    .stall_request_x        (mc_stall_request_x)
    );

// Interrupt unit
lm32_interrupt interrupt_unit (
    // ----- Inputs -------
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    // From external devices
    .interrupt              (interrupt),
    // From pipeline
    .stall_x                (stall_x),
    .non_debug_exception    (non_debug_exception_q_w),
    .debug_exception        (debug_exception_q_w),
    .eret_q_x               (eret_k_q_x),
    .bret_q_x               (bret_k_q_x),
    .csr                    (csr_x),
    .csr_write_data         (operand_1_x),
    .csr_write_enable       (csr_write_enable_k_q_x),
    // ----- Outputs -------
    .interrupt_exception    (interrupt_exception),
    // To pipeline
    .csr_read_data          (interrupt_csr_read_data_x)
    );


// Debug unit
lm32_debug #(
    .breakpoints            (breakpoints),
    .watchpoints            (watchpoints)
  ) hw_debug (
    // ----- Inputs -------
    .clk_i                  (clk_i),
    .rst_i                  (rst_i),
    .pc_x                   (pc_x),
    .load_x                 (load_x),
    .store_x                (store_x),
    .load_store_address_x   (adder_result_x),
    .csr_write_enable_x     (csr_write_enable_k_q_x),
    .csr_write_data         (operand_1_x),
    .csr_x                  (csr_x),
    .eret_q_x               (eret_k_q_x),
    .bret_q_x               (bret_k_q_x),
    .stall_x                (stall_x),
    .exception_x            (exception_x),
    .q_x                    (q_x),
    .dcache_refill_request  (dcache_refill_request),
    // ----- Outputs -------
    .dc_ss                  (dc_ss),
    .dc_re                  (dc_re),
    .bp_match               (bp_match),
    .wp_match               (wp_match)
    );

// Register file

   /*----------------------------------------------------------------------
    Register File is implemented using EBRs. There can be three accesses to
    the register file in each cycle: two reads and one write. On-chip block
    RAM has two read/write ports. To accomodate three accesses, two on-chip
    block RAMs are used (each register file "write" is made to both block
    RAMs).

    One limitation of the on-chip block RAMs is that one cannot perform a
    read and write to same location in a cycle (if this is done, then the
    data read out is indeterminate).
    ----------------------------------------------------------------------*/
   wire [31:0] regfile_data_0, regfile_data_1;
   reg [31:0]  w_result_d;
   reg         regfile_raw_0, regfile_raw_0_nxt;
   reg         regfile_raw_1, regfile_raw_1_nxt;

   /*----------------------------------------------------------------------
    Check if read and write is being performed to same register in current
    cycle? This is done by comparing the read and write IDXs.
    ----------------------------------------------------------------------*/
   always @(reg_write_enable_q_w or write_idx_w or instruction_f)
     begin
        if (reg_write_enable_q_w
            && (write_idx_w == instruction_f[25:21]))
          regfile_raw_0_nxt = 1'b1;
        else
          regfile_raw_0_nxt = 1'b0;

        if (reg_write_enable_q_w
            && (write_idx_w == instruction_f[20:16]))
          regfile_raw_1_nxt = 1'b1;
        else
          regfile_raw_1_nxt = 1'b0;
     end

   /*----------------------------------------------------------------------
    Select latched (delayed) write value or data from register file. If
    read in previous cycle was performed to register written to in same
    cycle, then latched (delayed) write value is selected.
    ----------------------------------------------------------------------*/
   always @(regfile_raw_0 or w_result_d or regfile_data_0)
     if (regfile_raw_0)
       reg_data_live_0 = w_result_d;
     else
       reg_data_live_0 = regfile_data_0;

   /*----------------------------------------------------------------------
    Select latched (delayed) write value or data from register file. If
    read in previous cycle was performed to register written to in same
    cycle, then latched (delayed) write value is selected.
    ----------------------------------------------------------------------*/
   always @(regfile_raw_1 or w_result_d or regfile_data_1)
     if (regfile_raw_1)
       reg_data_live_1 = w_result_d;
     else
       reg_data_live_1 = regfile_data_1;

   /*----------------------------------------------------------------------
    Latch value written to register file
    ----------------------------------------------------------------------*/
   always @(posedge clk_i )
     if (rst_i == 1'b1)
       begin
          regfile_raw_0 <= 1'b0;
          regfile_raw_1 <= 1'b0;
          w_result_d <= 32'b0;
       end
     else
       begin
          regfile_raw_0 <= regfile_raw_0_nxt;
          regfile_raw_1 <= regfile_raw_1_nxt;
          w_result_d <= w_result;
       end

   /*----------------------------------------------------------------------
    Register file instantiation as Pseudo-Dual Port EBRs.
    ----------------------------------------------------------------------*/
   // Modified by GSI: removed non-portable RAM instantiation
   lm32_ram
     #(
       // ----- Parameters -----
       .data_width(32),
       .address_width(5)
       )
   reg_0
     (
      // ----- Inputs -----
      .read_clk      (clk_i),
      .write_clk     (clk_i),
      .reset         (rst_i),
      .enable_read   (1'b1),
      .read_address  (instruction_f[25:21]),
      .enable_write  (1'b1),
      .write_address (write_idx_w),
      .write_data    (w_result),
      .write_enable  (reg_write_enable_q_w),
      // ----- Outputs -----
      .read_data     (regfile_data_0)
      );

   lm32_ram
     #(
       .data_width(32),
       .address_width(5)
       )
   reg_1
     (
      // ----- Inputs -----
      .read_clk      (clk_i),
      .write_clk     (clk_i),
      .reset         (rst_i),
      .enable_read   (1'b1),
      .read_address  (instruction_f[20:16]),
      .enable_write  (1'b1),
      .write_address (write_idx_w),
      .write_data    (w_result),
      .write_enable  (reg_write_enable_q_w),
      // ----- Outputs -----
      .read_data     (regfile_data_1)
      );



/////////////////////////////////////////////////////
// Combinational Logic
/////////////////////////////////////////////////////

// Select between buffered and live data from register file
assign reg_data_0 = use_buf ? reg_data_buf_0 : reg_data_live_0;
assign reg_data_1 = use_buf ? reg_data_buf_1 : reg_data_live_1;

// Detect read-after-write hazzards
assign raw_x_0 = (write_idx_x == read_idx_0_d) && (write_enable_q_x == 1'b1);
assign raw_m_0 = (write_idx_m == read_idx_0_d) && (write_enable_q_m == 1'b1);
assign raw_w_0 = (write_idx_w == read_idx_0_d) && (write_enable_q_w == 1'b1);
assign raw_x_1 = (write_idx_x == read_idx_1_d) && (write_enable_q_x == 1'b1);
assign raw_m_1 = (write_idx_m == read_idx_1_d) && (write_enable_q_m == 1'b1);
assign raw_w_1 = (write_idx_w == read_idx_1_d) && (write_enable_q_w == 1'b1);

// Interlock detection - Raise an interlock for RAW hazzards
always @(*)
begin
    if (   (   (x_bypass_enable_x == 1'b0)
            && (   ((read_enable_0_d == 1'b1) && (raw_x_0 == 1'b1))
                || ((read_enable_1_d == 1'b1) && (raw_x_1 == 1'b1))
               )
           )
        || (   (m_bypass_enable_m == 1'b0)
            && (   ((read_enable_0_d == 1'b1) && (raw_m_0 == 1'b1))
                || ((read_enable_1_d == 1'b1) && (raw_m_1 == 1'b1))
               )
           )
       )
        interlock = 1'b1;
    else
        interlock = 1'b0;
end

// Bypass for reg port 0
always @(*)
begin
    if (raw_x_0 == 1'b1)
        bypass_data_0 = x_result;
    else if (raw_m_0 == 1'b1)
        bypass_data_0 = m_result;
    else if (raw_w_0 == 1'b1)
        bypass_data_0 = w_result;
    else
        bypass_data_0 = reg_data_0;
end

// Bypass for reg port 1
always @(*)
begin
    if (raw_x_1 == 1'b1)
        bypass_data_1 = x_result;
    else if (raw_m_1 == 1'b1)
        bypass_data_1 = m_result;
    else if (raw_w_1 == 1'b1)
        bypass_data_1 = w_result;
    else
        bypass_data_1 = reg_data_1;
end

   /*----------------------------------------------------------------------
    Branch prediction is performed in D stage of pipeline. Only PC-relative
    branches are predicted: forward-pointing conditional branches are not-
    taken, while backward-pointing conditional branches are taken.
    Unconditional branches are always predicted taken!
    ----------------------------------------------------------------------*/
   assign branch_predict_d = bi_unconditional | bi_conditional;
   assign branch_predict_taken_d = bi_unconditional ? 1'b1 : (bi_conditional ? instruction_d[15] : 1'b0);

   // Compute branch target address: Branch PC PLUS Offset
   assign branch_target_d = pc_d + branch_offset_d;

   // Compute fetch address. Address of instruction sequentially after the
   // branch if branch is not taken. Target address of branch is branch is
   // taken
   assign branch_predict_address_d = branch_predict_taken_d ? branch_target_d : pc_f;

// D stage result selection
always @(*)
begin
    d_result_0 = d_result_sel_0_d[0] ? {pc_f, 2'b00} : bypass_data_0;
    case (d_result_sel_1_d)
    2'b00:      d_result_1 = {32{1'b0}};
    2'b01:     d_result_1 = bypass_data_1;
    2'b10: d_result_1 = immediate_d;
    default:                        d_result_1 = {32{1'bx}};
    endcase
end


// Sign-extension
assign sextb_result_x = {{24{operand_0_x[7]}}, operand_0_x[7:0]};
assign sexth_result_x = {{16{operand_0_x[15]}}, operand_0_x[15:0]};
assign sext_result_x = size_x == 2'b00 ? sextb_result_x : sexth_result_x;


// Condition evaluation
assign cmp_zero = operand_0_x == operand_1_x;
assign cmp_negative = adder_result_x[32-1];
assign cmp_overflow = adder_overflow_x;
assign cmp_carry_n = adder_carry_n_x;
always @(*)
begin
    case (condition_x)
    3'b000:   condition_met_x = 1'b1;
    3'b110:   condition_met_x = 1'b1;
    3'b001:    condition_met_x = cmp_zero;
    3'b111:   condition_met_x = !cmp_zero;
    3'b010:    condition_met_x = !cmp_zero && (cmp_negative == cmp_overflow);
    3'b101:   condition_met_x = cmp_carry_n && !cmp_zero;
    3'b011:   condition_met_x = cmp_negative == cmp_overflow;
    3'b100:  condition_met_x = cmp_carry_n;
    default:              condition_met_x = 1'bx;
    endcase
end

// X stage result selection
always @(*)
begin
    x_result =   x_result_sel_add_x ? adder_result_x
               : x_result_sel_csr_x ? csr_read_data_x
               : x_result_sel_sext_x ? sext_result_x
               : x_result_sel_mc_arith_x ? mc_result_x
               : logic_result_x;
end

// M stage result selection
always @(*)
begin
    m_result =   m_result_sel_compare_m ? {{32-1{1'b0}}, condition_met_m}
               : m_result_sel_shift_m ? shifter_result_m
               : operand_m;
end

// W stage result selection
always @(*)
begin
    w_result =    w_result_sel_load_w ? load_data_w
                : w_result_sel_mul_w ? multiplier_result_w
                : operand_w;
end


// Indicate when a branch should be taken in M stage (exceptions are a type of branch)
assign branch_taken_m =      (stall_m == 1'b0)
                          && (   (   (branch_m == 1'b1)
                                  && (valid_m == 1'b1)
                                  && (   (   (condition_met_m == 1'b1)
                                          && (branch_predict_taken_m == 1'b0)
                                         )
                                      || (   (condition_met_m == 1'b0)
                                          && (branch_predict_m == 1'b1)
                                          && (branch_predict_taken_m == 1'b1)
                                         )
                                     )
                                 )
                              || (exception_m == 1'b1)
                             );

// Indicate when a branch in M stage is mispredicted as being taken
assign branch_mispredict_taken_m =    (condition_met_m == 1'b0)
                                   && (branch_predict_m == 1'b1)
                                   && (branch_predict_taken_m == 1'b1);

// Indicate when a branch in M stage will cause flush in X stage
assign branch_flushX_m =    (stall_m == 1'b0)
                         && (   (   (branch_m == 1'b1)
                                 && (valid_m == 1'b1)
                                 && (   (condition_met_m == 1'b1)
                                     || (   (condition_met_m == 1'b0)
                                         && (branch_predict_m == 1'b1)
                                         && (branch_predict_taken_m == 1'b1)
                                        )
                                    )
                                )
                             || (exception_m == 1'b1)
                            );

// Generate signal that will kill instructions in each pipeline stage when necessary
assign kill_f =    (   (valid_d == 1'b1)
                    && (branch_predict_taken_d == 1'b1)
                   )
                || (branch_taken_m == 1'b1)
                || (icache_refill_request == 1'b1)
                || (dcache_refill_request == 1'b1)
                || (itlb_miss_exception == 1'b1)
                ;
assign kill_d =    (branch_taken_m == 1'b1)
                || (icache_refill_request == 1'b1)
                || (dcache_refill_request == 1'b1)
                || (itlb_miss_exception == 1'b1)
                ;
assign kill_x =    (branch_flushX_m == 1'b1)
                || (dcache_refill_request == 1'b1)
                ;
assign kill_m =    1'b0
                || (dcache_refill_request == 1'b1)
                ;
assign kill_w =    1'b0
                || (dcache_refill_request == 1'b1)
                ;

// Exceptions

assign breakpoint_exception =    (   (   (break_x == 1'b1)
                                      || (bp_match == 1'b1)
                                     )
                                  && (valid_x == 1'b1)
                                 )
                              || (ext_break_r == 1'b1)
                              ;

assign watchpoint_exception = wp_match == 1'b1;

assign instruction_bus_error_exception = (   (bus_error_x == 1'b1)
                                          && (valid_x == 1'b1)
                                         );
assign data_bus_error_exception = data_bus_error_seen == 1'b1;

assign divide_by_zero_exception = divide_by_zero_x == 1'b1;

assign system_call_exception = (   (scall_x == 1'b1)
                                && (valid_x == 1'b1)
                               );

assign itlb_miss_exception = (   (itlb_miss_x == 1'b1)
                              && (itlbe == 1'b1)
                              && (valid_x == 1'b1)
                            );
assign itlb_exception = (itlb_miss_exception == 1'b1);

assign dtlb_miss_exception = (   (dtlb_miss_x == 1'b1)
                              && (dtlbe == 1'b1)
                              && (valid_x == 1'b1)
                            );
assign dtlb_fault_exception = (   (dtlb_fault_x == 1'b1)
                               && (dtlbe == 1'b1)
                               && (valid_x == 1'b1)
                            );
assign dtlb_exception = (dtlb_miss_exception == 1'b1) || (dtlb_fault_exception == 1'b1);

assign privilege_exception = (   (usr == 1'b1)
                              && (   (csr_write_enable_q_x == 1'b1)
                                  || (eret_q_x == 1'b1)
                                  || (bret_q_x == 1'b1)
                                 )
                             );

assign debug_exception_x =  (breakpoint_exception == 1'b1)
                         || (watchpoint_exception == 1'b1)
                         ;

assign non_debug_exception_x = (system_call_exception == 1'b1)
                            || (instruction_bus_error_exception == 1'b1)
                            || (data_bus_error_exception == 1'b1)
                            || (divide_by_zero_exception == 1'b1)
                            || (   (interrupt_exception == 1'b1)
                                && (dc_ss == 1'b0)
                                && (store_q_m == 1'b0)
                                && (D_CYC_O == 1'b0)
                               )
                            || (itlb_exception == 1'b1)
                            || (dtlb_exception == 1'b1)
                            || (privilege_exception == 1'b1)
                            ;

assign exception_x = (debug_exception_x == 1'b1) || (non_debug_exception_x == 1'b1);

// Exception ID
always @(*)
begin
         if (data_bus_error_exception == 1'b1)
        eid_x = 4'h4;
    else
         if (breakpoint_exception == 1'b1)
        eid_x = 4'h1;
    else
         if (data_bus_error_exception == 1'b1)
        eid_x = 4'h4;
    else
         if (instruction_bus_error_exception == 1'b1)
        eid_x = 4'h2;
    else
         if (watchpoint_exception == 1'b1)
        eid_x = 4'h3;
    else
         if (divide_by_zero_exception == 1'b1)
        eid_x = 4'h5;
    else
         if (   (interrupt_exception == 1'b1)
             && (dc_ss == 1'b0)
            )
        eid_x = 4'h6;
    else
         if (itlb_miss_exception == 1'b1)
        eid_x = 4'h8;
    else
         if (dtlb_miss_exception == 1'b1)
        eid_x = 4'h9;
    else
         if (dtlb_fault_exception == 1'b1)
        eid_x = 4'ha;
    else
         if (privilege_exception == 1'b1)
        eid_x = 4'hb;
    else
        eid_x = 4'h7;
end

// Stall generation

assign stall_a = (stall_f == 1'b1);

assign stall_f =   (stall_d == 1'b1)
                // We need to stall for one cycle. Otherwise the icache
                // starts one cycle earlier and the restart address will be
                // wrong in case of a miss, that is one instruction is
                // skipped.
                || (   (itlbe == 1'b1)
                    && (   (debug_exception_q_w == 1'b1)
                        || (non_debug_exception_q_w == 1'b1)
                       )
                   )
                ;

assign stall_d =   (stall_x == 1'b1)
                || (   (interlock == 1'b1)
                    && (kill_d == 1'b0)
                   )
                || (   (   (eret_d == 1'b1)
                        || (scall_d == 1'b1)
                        || (bus_error_d == 1'b1)
                       )
                    && (   (load_q_x == 1'b1)
                        || (load_q_m == 1'b1)
                        || (store_q_x == 1'b1)
                        || (store_q_m == 1'b1)
                        || (D_CYC_O == 1'b1)
                       )
                    && (kill_d == 1'b0)
                   )
                || (   (   (break_d == 1'b1)
                        || (bret_d == 1'b1)
                       )
                    && (   (load_q_x == 1'b1)
                        || (store_q_x == 1'b1)
                        || (load_q_m == 1'b1)
                        || (store_q_m == 1'b1)
                        || (D_CYC_O == 1'b1)
                       )
                    && (kill_d == 1'b0)
                   )
                || (   (csr_write_enable_d == 1'b1)
                    && (load_q_x == 1'b1)
                   )
                ;

assign stall_x =    (stall_m == 1'b1)
                 || (   (mc_stall_request_x == 1'b1)
                     && (kill_x == 1'b0)
                    )
                 ;

assign stall_m =    (stall_wb_load == 1'b1)
                 || (   (D_CYC_O == 1'b1)
                     && (   (store_m == 1'b1)
                         /*
                          Bug: Following loop does not allow interrupts to be services since
                          either D_CYC_O or store_m is always high during entire duration of
                          loop.
                          L1:   addi    r1, r1, 1
                                sw      (r2,0), r1
                                bi      L1

                          Introduce a single-cycle stall when a wishbone cycle is in progress
                          and a new store instruction is in Execute stage and a interrupt
                          exception has occured. This stall will ensure that D_CYC_O and
                          store_m will both be low for one cycle.
                          */
                         || ((store_x == 1'b1) && (interrupt_exception == 1'b1))
                         || (load_m == 1'b1)
                         || (load_x == 1'b1)
                        )
                    )
                 || (dcache_stall_request == 1'b1)     // Need to stall in case a taken branch is in M stage and data cache is only being flush, so wont be restarted
                 || (icache_stall_request == 1'b1)     // Pipeline needs to be stalled otherwise branches may be lost
                 || ((I_CYC_O == 1'b1) && ((branch_m == 1'b1) || (exception_m == 1'b1)))
                 || (itlb_stall_request == 1'b1)       // ITLB is busy
                 || (dtlb_stall_request == 1'b1)       // DTLB is busy or a lookup is in progress
                 ;

// Qualify state changing control signals
assign q_d = (valid_d == 1'b1) && (kill_d == 1'b0);
assign divide_q_d = (divide_d == 1'b1) && (q_d == 1'b1);
assign modulus_q_d = (modulus_d == 1'b1) && (q_d == 1'b1);
assign q_x = (valid_x == 1'b1) && (kill_x == 1'b0);
assign csr_write_enable_q_x = (csr_write_enable_x == 1'b1) && (q_x == 1'b1);
assign csr_write_enable_k_q_x = (csr_write_enable_q_x == 1'b1)
               && (usr == 1'b0)
                  ;
assign eret_q_x = (eret_x == 1'b1) && (q_x == 1'b1);
assign eret_k_q_x = (eret_q_x == 1'b1)
               && (usr == 1'b0)
                  ;
assign bret_q_x = (bret_x == 1'b1) && (q_x == 1'b1);
assign bret_k_q_x = (bret_q_x == 1'b1)
               && (usr == 1'b0)
                  ;
assign load_q_x = (load_x == 1'b1)
               && (q_x == 1'b1)
               && (bp_match == 1'b0)
                  ;
assign store_q_x = (store_x == 1'b1)
               && (q_x == 1'b1)
               && (bp_match == 1'b0)
                  ;
assign q_m = (valid_m == 1'b1) && (kill_m == 1'b0) && (exception_m == 1'b0);
assign load_q_m = (load_m == 1'b1) && (q_m == 1'b1);
assign store_q_m = (store_m == 1'b1) && (q_m == 1'b1);
assign debug_exception_q_w = ((debug_exception_w == 1'b1) && (valid_w == 1'b1));
assign non_debug_exception_q_w = ((non_debug_exception_w == 1'b1) && (valid_w == 1'b1));
// Don't qualify register write enables with kill, as the signal is needed early, and it doesn't matter if the instruction is killed (except for the actual write - but that is handled separately)
assign write_enable_q_x = (write_enable_x == 1'b1) && (valid_x == 1'b1) && (branch_flushX_m == 1'b0);
assign write_enable_q_m = (write_enable_m == 1'b1) && (valid_m == 1'b1);
assign write_enable_q_w = (write_enable_w == 1'b1) && (valid_w == 1'b1);
// The enable that actually does write the registers needs to be qualified with kill
assign reg_write_enable_q_w = (write_enable_w == 1'b1) && (kill_w == 1'b0) && (valid_w == 1'b1) || rst_i;

// Configuration (CFG) CSR
assign cfg = {
              6'h02,
              watchpoints[3:0],
              breakpoints[3:0],
              interrupts[5:0],
              1'b0,
              1'b1,
              1'b0,
              1'b1,
              1'b1,
              1'b1,
              1'b0,
              1'b0,
              1'b1,
              1'b1,
              1'b1,
              1'b1
              };

assign cfg2 = {
               1'b1,
               29'b0,
               1'b0,
               1'b0
               };

assign psw = {
              {32-12{1'b0}},
              busr,
              eusr,
              usr,
              bdtlbe,
              edtlbe,
              dtlbe,
              bitlbe,
              eitlbe,
              itlbe,
              interrupt_csr_read_data_x[2:0]
              };

// Cache flush
assign iflush = (   (csr_write_enable_d == 1'b1)
                 && (csr_d == 5'h3)
                 && (stall_d == 1'b0)
                 && (kill_d == 1'b0)
                 && (valid_d == 1'b1))
// Added by GSI: needed to flush cache after loading firmware per JTAG
                 ;
assign dflush_x = (   (csr_write_enable_q_x == 1'b1)
                   && (csr_x == 5'h4))
// Added by GSI: needed to flush cache after loading firmware per JTAG
                   ;

// Extract CSR index
assign csr_d = read_idx_0_d[(5-1):0];

// CSR reads
always @(*)
begin
    case (csr_x)
    5'h0,
    5'h1,
    5'h2:   csr_read_data_x = interrupt_csr_read_data_x;
    5'h6:  csr_read_data_x = cfg;
    5'h7:  csr_read_data_x = {eba, {(32-((32-2)-4-3)){1'b0}}};
    5'h9: csr_read_data_x = {deba, {(32-((32-2)-4-3)){1'b0}}};
    5'ha: csr_read_data_x = cfg2;
    5'h1d:  csr_read_data_x = psw;
    5'h1e: csr_read_data_x = tlbvaddr;
    5'h1f : csr_read_data_x = tlbbadvaddr;

    default:        csr_read_data_x = {32{1'bx}};
    endcase
end

/////////////////////////////////////////////////////
// Sequential Logic
/////////////////////////////////////////////////////

// Processor status word (PSW) handling
always @(posedge clk_i )
begin
    if (rst_i)
    begin
        itlbe <= 1'b0;
        eitlbe <= 1'b0;
        dtlbe <= 1'b0;
        edtlbe <= 1'b0;
        usr <= 1'b0;
        eusr <= 1'b0;
        bitlbe <= 1'b0;
        bdtlbe <= 1'b0;
        busr <= 1'b0;
    end
    else
    begin
        if (non_debug_exception_q_w == 1'b1)
        begin
            // Save and then clear ITLB and DTLB enable
            eitlbe <= itlbe;
            itlbe <= 1'b0;
            edtlbe <= dtlbe;
            dtlbe <= 1'b0;
            eusr <= usr;
            usr <= 1'b0;
        end
        else if (debug_exception_q_w == 1'b1)
        begin
            // Save and then clear TLB enable
            bitlbe <= itlbe;
            itlbe <= 1'b0;
            bdtlbe <= dtlbe;
            dtlbe <= 1'b0;
            busr <= usr;
            usr <= 1'b0;
        end

        else if (stall_x == 1'b0)
        begin
            if (eret_k_q_x == 1'b1)
            begin
                // Restore ITLB and DTLB enable
                itlbe <= eitlbe;
                dtlbe <= edtlbe;
                usr <= eusr;
            end
            else if (bret_k_q_x == 1'b1)
            begin
                // Restore ITLB and DTLB enable
                itlbe <= bitlbe;
                dtlbe <= bdtlbe;
                usr <= busr;
            end
            else if (csr_write_enable_k_q_x == 1'b1)
            begin
                // Handle wcsr write
                if (csr_x == 5'h1d)
                begin
                    // ie, eie and bie are shadowed from IE register
                    itlbe  <= operand_1_x[3];
                    eitlbe <= operand_1_x[4];
                    dtlbe  <= operand_1_x[6];
                    edtlbe <= operand_1_x[7];
                    usr    <= operand_1_x[9];
                    eusr   <= operand_1_x[10];
                    bitlbe <= operand_1_x[5];
                    bdtlbe <= operand_1_x[8];
                    busr   <= operand_1_x[11];
                end
            end
        end
    end
end

// TLBVADDR CSR
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        itlb_flush <= 1'b0;
        itlb_invalidate <= 1'b0;
        dtlb_flush <= 1'b0;
        dtlb_invalidate <= 1'b0;
        tlbvaddr <= {32{1'b0}};
    end
    else
    begin
        itlb_flush <= 1'b0;
        itlb_invalidate <= 1'b0;
        dtlb_flush <= 1'b0;
        dtlb_invalidate <= 1'b0;
        if (stall_x == 1'b0)
        begin
            if (dtlb_exception == 1'b1)
                tlbvaddr <= {dtlb_miss_vfn[32-1:1], 1'b1};
            else if (itlb_exception == 1'b1)
                tlbvaddr <= {itlb_miss_vfn[32-1:1], 1'b0};
            else if ((csr_write_enable_k_q_x == 1'b1) && (csr_x == 5'h1e))
            begin
                tlbvaddr <= operand_1_x;
                if (operand_1_x[0] == 1'b0)
                begin
                    case (operand_1_x[2:1])
                    2'h1:      itlb_flush <= 1'b1;
                    2'h2: itlb_invalidate <= 1'b1;
                    endcase
                end
                if (operand_1_x[0] == 1'b1)
                begin
                    case (operand_1_x[2:1])
                    2'h1:      dtlb_flush <= 1'b1;
                    2'h2: dtlb_invalidate <= 1'b1;
                    endcase
                end
            end
        end
    end
end

// TLBPADDR CSR
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        itlb_update <= 1'b0;
        dtlb_update <= 1'b0;
        tlbpaddr <= {32{1'b0}};
    end
    else
    begin
        itlb_update <= 1'b0;
        dtlb_update <= 1'b0;
        if ((csr_write_enable_k_q_x == 1'b1) && (csr_x == 5'h1f ) && (stall_x == 1'b0))
        begin
            /* updates take change in the M stage */
            tlbpaddr <= operand_1_x;
            if (operand_1_x[0] == 1'b0)
                itlb_update <= 1'b1;
            if (operand_1_x[0] == 1'b1)
                dtlb_update <= 1'b1;
        end
    end
end

// TLBBADVADDR CSR
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        tlbbadvaddr <= {32{1'b0}};
    else
    begin
        if (stall_x == 1'b0)
        begin
            if (dtlb_exception == 1'b1)
                tlbbadvaddr <= adder_result_x;
            else if (itlb_exception == 1'b1)
                tlbbadvaddr <= {pc_x, {32-(32-2){1'b0}}};
        end
    end
end

// Exception Base Address (EBA) CSR
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        eba <= eba_reset[((32-2)+2-1):(4+3+2)];
    else
    begin
        if ((csr_write_enable_k_q_x == 1'b1) && (csr_x == 5'h7) && (stall_x == 1'b0))
            eba <= operand_1_x[((32-2)+2-1):(4+3+2)];
    end
end

// Debug Exception Base Address (DEBA) CSR
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        deba <= deba_reset[((32-2)+2-1):(4+3+2)];
    else
    begin
        if ((csr_write_enable_k_q_x == 1'b1) && (csr_x == 5'h9) && (stall_x == 1'b0))
            deba <= operand_1_x[((32-2)+2-1):(4+3+2)];
    end
end

// Cycle Counter (CC) CSR

// Watch for data bus errors
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        data_bus_error_seen <= 1'b0;
    else
    begin
        // Set flag when bus error is detected
        if ((D_ERR_I == 1'b1) && (D_CYC_O == 1'b1))
            data_bus_error_seen <= 1'b1;
        // Clear flag when exception is taken
        if ((exception_m == 1'b1) && (kill_m == 1'b0))
            data_bus_error_seen <= 1'b0;
    end
end

always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
        ext_break_r <= 1'b0;
    else
    begin
        if (ext_break == 1'b1)
            ext_break_r <= 1'b1;
        if (debug_exception_q_w == 1'b1)
            ext_break_r <= 1'b0;
    end
end

// Valid bits to indicate whether an instruction in a partcular pipeline stage is valid or not

always @(*)
begin
    if (   (icache_refill_request == 1'b1)
        || (dcache_refill_request == 1'b1)
       )
        valid_a = 1'b0;
    else if (   (icache_restart_request == 1'b1)
             || (dcache_restart_request == 1'b1)
            )
        valid_a = 1'b1;
    else
        valid_a = !icache_refilling && !dcache_refilling;
end

always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        valid_f <= 1'b0;
        valid_d <= 1'b0;
        valid_x <= 1'b0;
        valid_m <= 1'b0;
        valid_w <= 1'b0;
    end
    else
    begin
        if ((kill_f == 1'b1) || (stall_a == 1'b0))
            valid_f <= valid_a;
        else if (stall_f == 1'b0)
            valid_f <= 1'b0;

        if (kill_d == 1'b1)
            valid_d <= 1'b0;
        else if (stall_f == 1'b0)
            valid_d <= valid_f & !kill_f;
        else if (stall_d == 1'b0)
            valid_d <= 1'b0;

        if (stall_d == 1'b0)
            valid_x <= valid_d & !kill_d;
        else if (kill_x == 1'b1)
            valid_x <= 1'b0;
        else if (stall_x == 1'b0)
            valid_x <= 1'b0;

        if (kill_m == 1'b1)
            valid_m <= 1'b0;
        else if (stall_x == 1'b0)
            valid_m <= valid_x & !kill_x;
        else if (stall_m == 1'b0)
            valid_m <= 1'b0;

        if (stall_m == 1'b0)
            valid_w <= valid_m & !kill_m;
        else
            valid_w <= 1'b0;
    end
end

// Microcode pipeline registers
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        operand_0_x <= {32{1'b0}};
        operand_1_x <= {32{1'b0}};
        store_operand_x <= {32{1'b0}};
        branch_target_x <= {(32-2){1'b0}};
        x_result_sel_csr_x <= 1'b0;
        x_result_sel_mc_arith_x <= 1'b0;
        x_result_sel_sext_x <= 1'b0;
        x_result_sel_logic_x <= 1'b0;
        x_result_sel_add_x <= 1'b0;
        m_result_sel_compare_x <= 1'b0;
        m_result_sel_shift_x <= 1'b0;
        w_result_sel_load_x <= 1'b0;
        w_result_sel_mul_x <= 1'b0;
        x_bypass_enable_x <= 1'b0;
        m_bypass_enable_x <= 1'b0;
        write_enable_x <= 1'b0;
        write_idx_x <= {5{1'b0}};
        csr_x <= {5{1'b0}};
        load_x <= 1'b0;
        store_x <= 1'b0;
        size_x <= {2{1'b0}};
        sign_extend_x <= 1'b0;
        adder_op_x <= 1'b0;
        adder_op_x_n <= 1'b0;
        logic_op_x <= 4'h0;
        direction_x <= 1'b0;
        branch_x <= 1'b0;
        branch_predict_x <= 1'b0;
        branch_predict_taken_x <= 1'b0;
        condition_x <= 3'b000;
        break_x <= 1'b0;
        scall_x <= 1'b0;
        eret_x <= 1'b0;
        bret_x <= 1'b0;
        bus_error_x <= 1'b0;
        data_bus_error_exception_m <= 1'b0;
        csr_write_enable_x <= 1'b0;
        operand_m <= {32{1'b0}};
        branch_target_m <= {(32-2){1'b0}};
        m_result_sel_compare_m <= 1'b0;
        m_result_sel_shift_m <= 1'b0;
        w_result_sel_load_m <= 1'b0;
        w_result_sel_mul_m <= 1'b0;
        m_bypass_enable_m <= 1'b0;
        branch_m <= 1'b0;
        branch_predict_m <= 1'b0;
        branch_predict_taken_m <= 1'b0;
        exception_m <= 1'b0;
        load_m <= 1'b0;
        store_m <= 1'b0;
        write_enable_m <= 1'b0;
        write_idx_m <= {5{1'b0}};
        condition_met_m <= 1'b0;
        dflush_m <= 1'b0;
        debug_exception_m <= 1'b0;
        non_debug_exception_m <= 1'b0;
        operand_w <= {32{1'b0}};
        w_result_sel_load_w <= 1'b0;
        w_result_sel_mul_w <= 1'b0;
        write_idx_w <= {5{1'b0}};
        write_enable_w <= 1'b0;
        debug_exception_w <= 1'b0;
        non_debug_exception_w <= 1'b0;
        memop_pc_w <= {(32-2){1'b0}};
    end
    else
    begin
        // D/X stage registers

        if (stall_x == 1'b0)
        begin
            operand_0_x <= d_result_0;
            operand_1_x <= d_result_1;
            store_operand_x <= bypass_data_1;
            branch_target_x <= branch_reg_d == 1'b1 ? bypass_data_0[((32-2)+2-1):2] : branch_target_d;
            x_result_sel_csr_x <= x_result_sel_csr_d;
            x_result_sel_mc_arith_x <= x_result_sel_mc_arith_d;
            x_result_sel_sext_x <= x_result_sel_sext_d;
            x_result_sel_logic_x <= x_result_sel_logic_d;
            x_result_sel_add_x <= x_result_sel_add_d;
            m_result_sel_compare_x <= m_result_sel_compare_d;
            m_result_sel_shift_x <= m_result_sel_shift_d;
            w_result_sel_load_x <= w_result_sel_load_d;
            w_result_sel_mul_x <= w_result_sel_mul_d;
            x_bypass_enable_x <= x_bypass_enable_d;
            m_bypass_enable_x <= m_bypass_enable_d;
            load_x <= load_d;
            store_x <= store_d;
            branch_x <= branch_d;
            branch_predict_x <= branch_predict_d;
            branch_predict_taken_x <= branch_predict_taken_d;
            write_idx_x <= write_idx_d;
            csr_x <= csr_d;
            size_x <= size_d;
            sign_extend_x <= sign_extend_d;
            adder_op_x <= adder_op_d;
            adder_op_x_n <= ~adder_op_d;
            logic_op_x <= logic_op_d;
            direction_x <= direction_d;
            condition_x <= condition_d;
            csr_write_enable_x <= csr_write_enable_d;
            break_x <= break_d;
            scall_x <= scall_d;
            bus_error_x <= bus_error_d;
            eret_x <= eret_d;
            bret_x <= bret_d;
            write_enable_x <= write_enable_d;
        end

        // X/M stage registers

        if (stall_m == 1'b0)
        begin
            operand_m <= x_result;
            m_result_sel_compare_m <= m_result_sel_compare_x;
            m_result_sel_shift_m <= m_result_sel_shift_x;
            if (exception_x == 1'b1)
            begin
                w_result_sel_load_m <= 1'b0;
                w_result_sel_mul_m <= 1'b0;
            end
            else
            begin
                w_result_sel_load_m <= w_result_sel_load_x;
                w_result_sel_mul_m <= w_result_sel_mul_x;
            end
            m_bypass_enable_m <= m_bypass_enable_x;
            load_m <= load_x;
            store_m <= store_x;
            branch_m <= branch_x;
            branch_predict_m <= branch_predict_x;
            branch_predict_taken_m <= branch_predict_taken_x;
            // Data bus errors are generated by the wishbone and are
            // made known to the processor only in next cycle (as a
            // non-debug exception). A break instruction can be seen
            // in same cycle (causing a debug exception). Handle non
            // -debug exception first!
            if (non_debug_exception_x == 1'b1)
                write_idx_m <= 5'd30;
            else if (debug_exception_x == 1'b1)
                write_idx_m <= 5'd31;
            else
                write_idx_m <= write_idx_x;
            condition_met_m <= condition_met_x;
            if (exception_x == 1'b1)
                if (   (dc_re == 1'b1)
                    || (   (debug_exception_x == 1'b1)
                        && (non_debug_exception_x == 1'b0))
                   )
                    branch_target_m <= {deba, eid_x, {3{1'b0}}};
                else
                    branch_target_m <= {eba, eid_x, {3{1'b0}}};
            else
                branch_target_m <= branch_target_x;
            dflush_m <= dflush_x;
            eret_m <= eret_k_q_x;
            bret_m <= bret_k_q_x;
            write_enable_m <= exception_x == 1'b1 ? 1'b1 : write_enable_x;
            debug_exception_m <= debug_exception_x;
            non_debug_exception_m <= non_debug_exception_x;
        end

        // State changing regs
        if (stall_m == 1'b0)
        begin
            if ((exception_x == 1'b1) && (q_x == 1'b1) && (stall_x == 1'b0))
                exception_m <= 1'b1;
            else
                exception_m <= 1'b0;
            data_bus_error_exception_m <=    (data_bus_error_exception == 1'b1)
                                          ;
        end

        // M/W stage registers
        operand_w <= exception_m == 1'b1 ? (data_bus_error_exception_m ? {memop_pc_w, 2'b00} : {pc_m, 2'b00}) : m_result;
        w_result_sel_load_w <= w_result_sel_load_m;
        w_result_sel_mul_w <= w_result_sel_mul_m;
        write_idx_w <= write_idx_m;
        write_enable_w <= write_enable_m;
        debug_exception_w <= debug_exception_m;
        non_debug_exception_w <= non_debug_exception_m;
        if (   (stall_m == 1'b0)
            && (data_bus_error_exception == 1'b0)
            && (   (load_q_m == 1'b1)
                || (store_q_m == 1'b1)
               )
           )
          memop_pc_w <= pc_m;
    end
end

// Buffer data read from register file, in case a stall occurs, and watch for
// any writes to the modified registers
always @(posedge clk_i )
begin
    if (rst_i == 1'b1)
    begin
        use_buf <= 1'b0;
        reg_data_buf_0 <= {32{1'b0}};
        reg_data_buf_1 <= {32{1'b0}};
    end
    else
    begin
        if (stall_d == 1'b0)
            use_buf <= 1'b0;
        else if (use_buf == 1'b0)
        begin
            reg_data_buf_0 <= reg_data_live_0;
            reg_data_buf_1 <= reg_data_live_1;
            use_buf <= 1'b1;
        end
        if (reg_write_enable_q_w == 1'b1)
        begin
            if (write_idx_w == read_idx_0_d)
                reg_data_buf_0 <= w_result;
            if (write_idx_w == read_idx_1_d)
                reg_data_buf_1 <= w_result;
        end
    end
end



/////////////////////////////////////////////////////
// Behavioural Logic
/////////////////////////////////////////////////////

// synthesis translate_off

// Reset register 0. Only needed for simulation.
initial
begin
    reg_0.mem[0] = {32{1'b0}};
    reg_1.mem[0] = {32{1'b0}};
end

// synthesis translate_on

endmodule  