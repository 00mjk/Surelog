/*
 * LatticeMico32
 * True dual-ported RAM
 *
 * Copyright (c) 2012 Michael Walle <michael@walle.cc>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//   ==================================================================
//   >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
//   ------------------------------------------------------------------
//   Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
//   ------------------------------------------------------------------
//
//   IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
//   Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.
//
//   Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user's design for consistency and functionality through
//      the use of formal verification methods.
//
//   --------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
//   --------------------------------------------------------------------
//                         FILE DETAILS
// Project          : LatticeMico32
// File             : lm32_include.v
// Title            : CPU global macros
// Version          : 6.1.17
//                  : Initial Release
// Version          : 7.0SP2, 3.0
//                  : No Change
// Version          : 3.1
//                  : No Change
// Version          : 3.2
//                  : No Change
// Version          : 3.3
//                  : Support for extended configuration register
// =============================================================================


//
// Common configuration options
//






// Enable Debugging
//`define CFG_JTAG_ENABLED
//`define CFG_JTAG_UART_ENABLED
//`define CFG_HW_DEBUG_ENABLED

// Enable MMU



//
// End of common configuration options
//


// Wishbone configuration

// Data-path width

// Register file size

// Standard register numbers

// Range of Program Counter. Two LSBs are always 0.

// Range of an instruction

// Adder operation

// Shift direction

// Bus errors

// Derive macro that indicates whether we have single-stepping or not

// Derive macro that indicates whether JTAG interface is required

// Derive macro that indicates whether ROM debug is required

// Derive macro that indicates whether we have a barrel-shifter or not

// Derive macro that indicates whether we have a multiplier or not

// Derive a macro that indicates whether or not the multi-cycle arithmetic unit is required

// Derive macro that indicates if we are using an EBR register file

// Revision number

// Logical operations - Function encoded directly in instruction

// Conditions for conditional branches

// Size of load or store instruction - Encoding corresponds to opcode

// Width and range of a CSR index

// CSR indices

// Values for WPC CSR

// TLB operation codes

// Exception IDs

// Exception Base Address

// Pipeline result selection mux controls




// Derive a macro to indicate if either of the caches are implemented

/////////////////////////////////////////////////////
// Interrupts
/////////////////////////////////////////////////////

// Always enable interrupts

// Currently this is fixed to 32 and should not be changed

/////////////////////////////////////////////////////
// General
/////////////////////////////////////////////////////

// Sub-word range types

// Word sub-byte indicies

// Word sub-halfword indices

// Use a synchronous reset

// Wishbone defines
// Refer to Wishbone System-on-Chip Interconnection Architecture
// These should probably be moved to a Wishbone common file

// Wishbone cycle types

// Wishbone burst types


/////////////////////////////////////////////////////
// Module interface
/////////////////////////////////////////////////////

module lm32_dp_ram (
    // ----- Inputs -------
    clk_a,
    clk_b,
    ce_a,
    ce_b,
    addr_a,
    addr_b,
    di_a,
    di_b,
    we_a,
    we_b,
    // ----- Outputs -------
    do_a,
    do_b
    );

/////////////////////////////////////////////////////
// Parameters
/////////////////////////////////////////////////////

parameter data_width = 1;               // Width of the data ports
parameter address_width = 1;            // Width of the address ports
parameter init_file = "NONE";           // Initialization file

/////////////////////////////////////////////////////
// Inputs
/////////////////////////////////////////////////////

input clk_a;                            // Clock port A
input clk_b;                            // Clock port B

input ce_a;                             // Clock enable port A
input ce_b;                             // Clock enable port B
input [address_width-1:0] addr_a;       // Read/write address port A
input [address_width-1:0] addr_b;       // Read/write address port B
input [data_width-1:0] di_a;            // Data input port A
input [data_width-1:0] di_b;            // Data input port B
input we_a;                             // Write enable port A
input we_b;                             // Write enable port B

/////////////////////////////////////////////////////
// Outputs
/////////////////////////////////////////////////////

output [data_width-1:0] do_a;           // Data output port A
wire   [data_width-1:0] do_a;

output [data_width-1:0] do_b;           // Data output port B
wire   [data_width-1:0] do_b;

/////////////////////////////////////////////////////
// Internal nets and registers
/////////////////////////////////////////////////////

reg [data_width-1:0]    mem[0:(1<<address_width)-1];
reg [address_width-1:0] ra_a;           // Registered read address port A
reg [address_width-1:0] ra_b;           // Registered read address port B

/////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////

////////////////////////////////////////////////////
// Instantiations
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Combinational logic
/////////////////////////////////////////////////////

// Read ports
assign do_a = mem[ra_a];
assign do_b = mem[ra_b];

/////////////////////////////////////////////////////
// Sequential logic
/////////////////////////////////////////////////////

// Write ports
always @(posedge clk_a)
    if ((ce_a == 1'b1) && (we_a == 1'b1))
        mem[addr_a] <= di_a;

always @(posedge clk_b)
    if ((ce_b == 1'b1) && (we_b == 1'b1))
        mem[addr_b] <= di_b;

// Register read addresses for use on next cycle
always @(posedge clk_a)
    if (ce_a == 1'b1)
        ra_a <= addr_a;

always @(posedge clk_b)
    if (ce_b == 1'b1)
        ra_b <= addr_b;

/////////////////////////////////////////////////////
// Initialization
/////////////////////////////////////////////////////

generate
    if (init_file != "NONE")
    begin
initial $readmemh(init_file, mem);
    end
endgenerate
    
endmodule
