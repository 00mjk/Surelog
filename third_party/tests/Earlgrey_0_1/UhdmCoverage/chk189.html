
<!DOCTYPE html>
<html>
<head>
<style>
body {

}
p {
font-size: 14px;
}</style>
<h3>../src/lowrisc_ip_aes_0.6/rtl/aes_sbox_canright_masked_noreuse.sv Cov: 100% </h3>
<pre style="margin:0; padding:0 ">// Copyright lowRISC contributors.</pre>
<pre style="margin:0; padding:0 ">// Licensed under the Apache License, Version 2.0, see LICENSE for details.</pre>
<pre style="margin:0; padding:0 ">// SPDX-License-Identifier: Apache-2.0</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// AES Masked Canright SBox without Mask Re-Use</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// For details, see the following paper:</pre>
<pre style="margin:0; padding:0 ">// Canright, "A very compact 'perfectly masked' S-box for AES (corrected)"</pre>
<pre style="margin:0; padding:0 ">// available at https://eprint.iacr.org/2009/011.pdf</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// Note: This module implements the original masked inversion algorithm without re-using masks.</pre>
<pre style="margin:0; padding:0 ">// For details, see Section 2.2 of the paper.</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">///////////////////////////////////////////////////////////////////////////////////////////////////</pre>
<pre style="margin:0; padding:0 ">// IMPORTANT NOTE:                                                                               //</pre>
<pre style="margin:0; padding:0 ">//                            DO NOT USE THIS FOR SYNTHESIS BLINDLY!                             //</pre>
<pre style="margin:0; padding:0 ">//                                                                                               //</pre>
<pre style="margin:0; padding:0 ">// This is a high-level implementation targeting primarily RTL simulation. Synthesis tools might //</pre>
<pre style="margin:0; padding:0 ">// heavily optimize the design. The result is likely insecure. Use with care.                    //</pre>
<pre style="margin:0; padding:0 ">///////////////////////////////////////////////////////////////////////////////////////////////////</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">module aes_sbox_canright_masked_noreuse (</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  aes_pkg::ciph_op_e op_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [7:0]        data_i,     // masked, the actual input data is data_i ^ in_mask_i</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [7:0]        in_mask_i,  // input mask, independent from actual input data</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [7:0]        out_mask_i, // output mask, independent from input mask</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [7:0]        data_o      // masked, the actual output data is data_o ^ out_mask_i</pre>
<pre style="margin:0; padding:0 ">);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  import aes_pkg::*;</pre>
<pre style="margin:0; padding:0 ">  import aes_sbox_canright_pkg::*;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  ///////////////</pre>
<pre style="margin:0; padding:0 ">  // Functions //</pre>
<pre style="margin:0; padding:0 ">  ///////////////</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Masked inverse in GF(2^4), using normal basis [z^4, z]</pre>
<pre style="margin:0; padding:0 ">  // (see Formulas 6, 13, 14, 15, 16, 17 in the paper)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  function automatic logic [3:0] aes_masked_inverse_gf2p4(logic [3:0] b,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                                          logic [3:0] q,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                                          logic [1:0] r,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                                          logic [3:0] t);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    logic [3:0] b_inv;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    logic [1:0] b1, b0, q1, q0, c, c_inv, r_sq, t1, t0, b1_inv, b0_inv;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    b1 = b[3:2];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    b0 = b[1:0];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    q1 = q[3:2];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    q0 = q[1:0];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    t1 = t[3:2];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    t0 = t[1:0];</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Formula 13</pre>
<pre style="margin:0; padding:0 ">    // IMPORTANT: The following ops must be executed in order (left to right):</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    c = r ^ aes_scale_omega2_gf2p2(aes_square_gf2p2(b1 ^ b0))</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ^ aes_scale_omega2_gf2p2(aes_square_gf2p2(q1 ^ q0))</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ^ aes_mul_gf2p2(b1, b0)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ^ aes_mul_gf2p2(b1, q0) ^ aes_mul_gf2p2(b0, q1) ^ aes_mul_gf2p2(q1, q0);</pre>
<pre style="margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Formulas 14 and 15</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    c_inv = aes_square_gf2p2(c);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    r_sq  = aes_square_gf2p2(r);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Formulas 16 and 17</pre>
<pre style="margin:0; padding:0 ">    // IMPORTANT: The following ops must be executed in order (left to right):</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    b1_inv = t1 ^ aes_mul_gf2p2(b0, c_inv)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                ^ aes_mul_gf2p2(b0, r_sq) ^ aes_mul_gf2p2(q0, c_inv) ^ aes_mul_gf2p2(q0, r_sq);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    b0_inv = t0 ^ aes_mul_gf2p2(b1, c_inv)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                ^ aes_mul_gf2p2(b1, r_sq) ^ aes_mul_gf2p2(q1, c_inv) ^ aes_mul_gf2p2(q1, r_sq);</pre>
<pre style="margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Note: b_inv is masked by t, b was masked by q.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    b_inv = {b1_inv, b0_inv};</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    return b_inv;</pre>
<pre style="margin:0; padding:0 ">  endfunction</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Masked inverse in GF(2^8), using normal basis [y^16, y]</pre>
<pre style="margin:0; padding:0 ">  // (see Formulas 3, 12, 18 and 19 in the paper)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  function automatic logic [7:0] aes_masked_inverse_gf2p8(logic [7:0] a,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                                          logic [7:0] m,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                                          logic [7:0] n);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    logic [7:0] a_inv;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    logic [3:0] a1, a0, m1, m0, b, b_inv, q, s1, s0, t, a1_inv, a0_inv;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    logic [1:0] r;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a1 = a[7:4];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a0 = a[3:0];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    m1 = m[7:4];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    m0 = m[3:0];</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // q must be independent of m.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    q = n[7:4];</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Formula 12</pre>
<pre style="margin:0; padding:0 ">    // IMPORTANT: The following ops must be executed in order (left to right):</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    b = q ^ aes_square_scale_gf2p4_gf2p2(a1 ^ a0)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ^ aes_square_scale_gf2p4_gf2p2(m1 ^ m0)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ^ aes_mul_gf2p4(a1, a0)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ^ aes_mul_gf2p4(a1, m0) ^ aes_mul_gf2p4(a0, m1) ^ aes_mul_gf2p4(m1, m0);</pre>
<pre style="margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // r must be independent of q.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    r = m1[3:2];</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Note that the paper states the following requirements on t:</pre>
<pre style="margin:0; padding:0 ">    // - t must be independent of r.</pre>
<pre style="margin:0; padding:0 ">    // - t1 must be independent of q0, t0 must be independent of q1.</pre>
<pre style="margin:0; padding:0 ">    // - t must be independent of m (for the final steps involving s)</pre>
<pre style="margin:0; padding:0 ">    // The paper suggests to use t = q. To select s = n for the output mask (s must be independent</pre>
<pre style="margin:0; padding:0 ">    // of t = q = n[7:4]), we would need t = m0 or similar (not r, m1[3:2] though), but this would</pre>
<pre style="margin:0; padding:0 ">    // break the random product distribution of aes_mul_gf2p4(m0, t), or aes_mul_gf2p4(m1, t) below</pre>
<pre style="margin:0; padding:0 ">    // (see Lemma 2 in the paper). For this reason, we select t = q here and apply a final mask</pre>
<pre style="margin:0; padding:0 ">    // switch from s = m to n after the inversion.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    t = q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // b is masked by q, b_inv is masked by t.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    b_inv = aes_masked_inverse_gf2p4(b, q, r, t);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Note that the paper states the following requirements on s:</pre>
<pre style="margin:0; padding:0 ">    // - s must be independent of t</pre>
<pre style="margin:0; padding:0 ">    // - s1 must be independent of m0, s0 must be independent of m1.</pre>
<pre style="margin:0; padding:0 ">    // The paper suggests to use s = m (the input mask). To still end up with the specified output</pre>
<pre style="margin:0; padding:0 ">    // mask n, we will apply a final mask switch after the inversion.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    s1 = m1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    s0 = m0;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Formulas 18 and 19</pre>
<pre style="margin:0; padding:0 ">    // IMPORTANT: The following ops must be executed in order (left to right):</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a1_inv = s1 ^ aes_mul_gf2p4(a0, b_inv)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                ^ aes_mul_gf2p4(a0, t) ^ aes_mul_gf2p4(m0, b_inv) ^ aes_mul_gf2p4(m0, t);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a0_inv = s0 ^ aes_mul_gf2p4(a1, b_inv)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                ^ aes_mul_gf2p4(a1, t) ^ aes_mul_gf2p4(m1, b_inv) ^ aes_mul_gf2p4(m1, t);</pre>
<pre style="margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // Note: a_inv is now masked by s = m, a was masked by m.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_inv = {a1_inv, a0_inv};</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // To have a_inv masked by n (the specified output mask), we perform a final mask switch.</pre>
<pre style="margin:0; padding:0 ">    // IMPORTANT: The following ops must be executed in order (left to right):</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_inv = a_inv ^ n ^ m;</pre>
<pre style="margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    return a_inv;</pre>
<pre style="margin:0; padding:0 ">  endfunction</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  //////////////////////////</pre>
<pre style="margin:0; padding:0 ">  // Masked Canright SBox //</pre>
<pre style="margin:0; padding:0 ">  //////////////////////////</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [7:0] data_basis_x, data_inverse;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [7:0] in_mask_basis_x;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [7:0] out_mask_basis_x;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Convert data to normal basis X.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign data_basis_x = (op_i == CIPH_FWD) ? aes_mvm(data_i, A2X) :</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                             aes_mvm(data_i ^ 8'h63, S2X);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Convert masks to normal basis X.</pre>
<pre style="margin:0; padding:0 ">  // The addition of constant 8'h63 following the affine transformation is skipped.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign in_mask_basis_x  = (op_i == CIPH_FWD) ? aes_mvm(in_mask_i, A2X) :</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                                 aes_mvm(in_mask_i, S2X);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // The output mask is converted in the opposite direction.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign out_mask_basis_x = (op_i == CIPH_INV) ? aes_mvm(out_mask_i, A2X) :</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                                 aes_mvm(out_mask_i, S2X);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Do the inversion in normal basis X.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign data_inverse = aes_masked_inverse_gf2p8(data_basis_x, in_mask_basis_x, out_mask_basis_x);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Convert to basis S or A.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign data_o = (op_i == CIPH_FWD) ? (aes_mvm(data_inverse, X2S) ^ 8'h63) :</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                                       (aes_mvm(data_inverse, X2A));</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">endmodule</pre>
<pre style="margin:0; padding:0 "></pre>
</body>
</html>
