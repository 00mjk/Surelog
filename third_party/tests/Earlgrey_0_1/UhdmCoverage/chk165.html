
<!DOCTYPE html>
<html>
<head>
<style>
body {

}
p {
font-size: 14px;
}</style>
<h3>../src/pulp-platform_riscv-dbg_0.1_0/pulp_riscv_dbg/src/dm_mem.sv Cov: 98% </h3>
<pre style="margin:0; padding:0 ">/* Copyright 2018 ETH Zurich and University of Bologna.</pre>
<pre style="margin:0; padding:0 ">* Copyright and related rights are licensed under the Solderpad Hardware</pre>
<pre style="margin:0; padding:0 ">* License, Version 0.51 (the “License”); you may not use this file except in</pre>
<pre style="margin:0; padding:0 ">* compliance with the License.  You may obtain a copy of the License at</pre>
<pre style="margin:0; padding:0 ">* http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law</pre>
<pre style="margin:0; padding:0 ">* or agreed to in writing, software, hardware and materials distributed under</pre>
<pre style="margin:0; padding:0 ">* this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR</pre>
<pre style="margin:0; padding:0 ">* CONDITIONS OF ANY KIND, either express or implied. See the License for the</pre>
<pre style="margin:0; padding:0 ">* specific language governing permissions and limitations under the License.</pre>
<pre style="margin:0; padding:0 ">*</pre>
<pre style="margin:0; padding:0 ">* File:   dm_mem.sv</pre>
<pre style="margin:0; padding:0 ">* Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch></pre>
<pre style="margin:0; padding:0 ">* Date:   11.7.2018</pre>
<pre style="margin:0; padding:0 ">*</pre>
<pre style="margin:0; padding:0 ">* Description: Memory module for execution-based debug clients</pre>
<pre style="margin:0; padding:0 ">*</pre>
<pre style="margin:0; padding:0 ">*/</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">module dm_mem #(</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  parameter int unsigned        NrHarts          =  1,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  parameter int unsigned        BusWidth         = 32,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  parameter logic [NrHarts-1:0] SelectableHarts  = {NrHarts{1'b1}}</pre>
<pre style="margin:0; padding:0 ">) (</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic                             clk_i,       // Clock</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic                             rst_ni,      // debug module reset</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [NrHarts-1:0]               debug_req_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [19:0]                      hartsel_i,</pre>
<pre style="margin:0; padding:0 ">  // from Ctrl and Status register</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [NrHarts-1:0]               haltreq_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [NrHarts-1:0]               resumereq_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic                             clear_resumeack_i,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // state bits</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [NrHarts-1:0]               halted_o,    // hart acknowledge halt</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [NrHarts-1:0]               resuming_o,  // hart is resuming</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [dm::ProgBufSize-1:0][31:0] progbuf_i,    // program buffer to expose</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [dm::DataCount-1:0][31:0]   data_i,       // data in</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [dm::DataCount-1:0][31:0]   data_o,       // data out</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic                             data_valid_o, // data out is valid</pre>
<pre style="margin:0; padding:0 ">  // abstract command interface</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic                             cmd_valid_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  dm::command_t                     cmd_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic                             cmderror_valid_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output dm::cmderr_e                      cmderror_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic                             cmdbusy_o,</pre>
<pre style="margin:0; padding:0 ">  // data interface</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // SRAM interface</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic                             req_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic                             we_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [BusWidth-1:0]              addr_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [BusWidth-1:0]              wdata_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [BusWidth/8-1:0]            be_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [BusWidth-1:0]              rdata_o</pre>
<pre style="margin:0; padding:0 ">);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int unsigned DbgAddressBits = 12;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int unsigned HartSelLen     = (NrHarts == 1) ? 1 : $clog2(NrHarts);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int unsigned NrHartsAligned = 2**HartSelLen;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int unsigned MaxAar         = (BusWidth == 64) ? 4 : 3;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] DataBaseAddr        = (dm::DataAddr);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] DataEndAddr         = (dm::DataAddr + 4*dm::DataCount);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] ProgBufBaseAddr     = (dm::DataAddr - 4*dm::ProgBufSize);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] ProgBufEndAddr      = (dm::DataAddr - 1);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] AbstractCmdBaseAddr = (ProgBufBaseAddr - 4*10);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] AbstractCmdEndAddr  = (ProgBufBaseAddr - 1);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] WhereToAddr   = 'h300;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] FlagsBaseAddr = 'h400;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] FlagsEndAddr  = 'h7FF;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] HaltedAddr    = 'h100;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] GoingAddr     = 'h104;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] ResumingAddr  = 'h108;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam logic [DbgAddressBits-1:0] ExceptionAddr = 'h10C;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [dm::ProgBufSize/2-1:0][63:0]   progbuf;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [7:0][63:0]   abstract_cmd;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [NrHarts-1:0] halted_d, halted_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [NrHarts-1:0] resuming_d, resuming_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic               resume, go, going;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic exception;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic unsupported_command;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [63:0] rom_rdata;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [63:0] rdata_d, rdata_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic        word_enable32_q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // this is needed to avoid lint warnings related to array indexing</pre>
<pre style="margin:0; padding:0 ">  // resize hartsel to valid range</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [HartSelLen-1:0] hartsel, wdata_hartsel;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign hartsel       = hartsel_i[HartSelLen-1:0];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign wdata_hartsel = wdata_i[HartSelLen-1:0];</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [NrHartsAligned-1:0] resumereq_aligned, haltreq_aligned,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                             halted_d_aligned, halted_q_aligned,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                             halted_aligned, resumereq_wdata_aligned,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                             resuming_d_aligned, resuming_q_aligned;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign resumereq_aligned       = NrHartsAligned'(resumereq_i);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign haltreq_aligned         = NrHartsAligned'(haltreq_i);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign resumereq_wdata_aligned = NrHartsAligned'(resumereq_i);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign halted_q_aligned        = NrHartsAligned'(halted_q);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign halted_d                = NrHarts'(halted_d_aligned);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign resuming_q_aligned      = NrHartsAligned'(resuming_q);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign resuming_d              = NrHarts'(resuming_d_aligned);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // distinguish whether we need to forward data from the ROM or the FSM</pre>
<pre style="margin:0; padding:0 ">  // latch the address for this</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic fwd_rom_d, fwd_rom_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  dm::ac_ar_cmd_t ac_ar;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Abstract Command Access Register</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign ac_ar       = dm::ac_ar_cmd_t'(cmd_i.control);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign debug_req_o = haltreq_i;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign halted_o    = halted_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign resuming_o  = resuming_q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // reshape progbuf</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign progbuf = progbuf_i;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  typedef enum logic [1:0] { Idle, Go, Resume, CmdExecuting } state_e;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  state_e state_d, state_q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // hart ctrl queue</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  always_comb begin : p_hart_ctrl_queue</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    cmderror_valid_o = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    cmderror_o       = dm::CmdErrNone;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    state_d          = state_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    go               = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    resume           = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    cmdbusy_o        = 1'b1;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    unique case (state_q)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      Idle: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        cmdbusy_o = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (cmd_valid_i && halted_q_aligned[hartsel] && !unsupported_command) begin</pre>
<pre style="margin:0; padding:0 ">          // give the go signal</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          state_d = Go;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        end else if (cmd_valid_i) begin</pre>
<pre style="margin:0; padding:0 ">          // hart must be halted for all requests</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          cmderror_valid_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          cmderror_o = dm::CmdErrorHaltResume;</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">        // CSRs want to resume, the request is ignored when the hart is</pre>
<pre style="margin:0; padding:0 ">        // requested to halt or it didn't clear the resuming_q bit before</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (resumereq_aligned[hartsel] && !resuming_q_aligned[hartsel] &&</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            !haltreq_aligned[hartsel] && halted_q_aligned[hartsel]) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          state_d = Resume;</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      Go: begin</pre>
<pre style="margin:0; padding:0 ">        // we are already busy here since we scheduled the execution of a program</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        cmdbusy_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        go        = 1'b1;</pre>
<pre style="margin:0; padding:0 ">        // the thread is now executing the command, track its state</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (going) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            state_d = CmdExecuting;</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      Resume: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        cmdbusy_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        resume = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (resuming_q_aligned[hartsel]) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          state_d = Idle;</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      CmdExecuting: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        cmdbusy_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        go        = 1'b0;</pre>
<pre style="margin:0; padding:0 ">        // wait until the hart has halted again</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (halted_aligned[hartsel]) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          state_d = Idle;</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      default: ;</pre>
<pre style="margin:0; padding:0 ">    endcase</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // only signal once that cmd is unsupported so that we can clear cmderr</pre>
<pre style="margin:0; padding:0 ">    // in subsequent writes to abstractcs</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (unsupported_command && cmd_valid_i) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      cmderror_valid_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      cmderror_o = dm::CmdErrNotSupported;</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (exception) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      cmderror_valid_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      cmderror_o = dm::CmdErrorException;</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // word mux for 32bit and 64bit buses</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [63:0] word_mux;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign word_mux = (fwd_rom_q) ? rom_rdata : rdata_q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre id="id206" style="background-color: #FFB6C1; margin:0; padding:0 ">  if (BusWidth == 64) begin : gen_word_mux64</pre>
<pre id="id207" style="background-color: #FFB6C1; margin:0; padding:0 ">    assign rdata_o = word_mux;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  end else begin : gen_word_mux32</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    assign rdata_o = (word_enable32_q) ? word_mux[32 +: 32] : word_mux[0 +: 32];</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // read/write logic</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [63:0] data_bits;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [7:0][7:0] rdata;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  always_comb begin : p_rw_logic</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    halted_d_aligned   = NrHartsAligned'(halted_q);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    resuming_d_aligned = NrHartsAligned'(resuming_q);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    rdata_d        = rdata_q;</pre>
<pre style="margin:0; padding:0 ">    // convert the data in bits representation</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    data_bits      = data_i;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    rdata          = '0;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // write data in csr register</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    data_valid_o   = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    exception      = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    halted_aligned     = '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    going          = 1'b0;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // The resume ack signal is lowered when the resume request is deasserted</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (clear_resumeack_i) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      resuming_d_aligned[hartsel] = 1'b0;</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 ">    // we've got a new request</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (req_i) begin</pre>
<pre style="margin:0; padding:0 ">      // this is a write</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      if (we_i) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        unique case (addr_i[DbgAddressBits-1:0]) inside</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          HaltedAddr: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            halted_aligned[wdata_hartsel] = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            halted_d_aligned[wdata_hartsel] = 1'b1;</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          GoingAddr: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            going = 1'b1;</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ResumingAddr: begin</pre>
<pre style="margin:0; padding:0 ">            // clear the halted flag as the hart resumed execution</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            halted_d_aligned[wdata_hartsel] = 1'b0;</pre>
<pre style="margin:0; padding:0 ">            // set the resuming flag which needs to be cleared by the debugger</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            resuming_d_aligned[wdata_hartsel] = 1'b1;</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="margin:0; padding:0 ">          // an exception occurred during execution</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          ExceptionAddr: exception = 1'b1;</pre>
<pre style="margin:0; padding:0 ">          // core can write data registers</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          [(dm::DataAddr):DataEndAddr]: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            data_valid_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            for (int i = 0; i < $bits(be_i); i++) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              if (be_i[i]) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                data_bits[i*8+:8] = wdata_i[i*8+:8];</pre>
<pre style="margin:0; padding:0 ">              end</pre>
<pre style="margin:0; padding:0 ">            end</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          default ;</pre>
<pre style="margin:0; padding:0 ">        endcase</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">      // this is a read</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        unique case (addr_i[DbgAddressBits-1:0]) inside</pre>
<pre style="margin:0; padding:0 ">          // variable ROM content</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          WhereToAddr: begin</pre>
<pre style="margin:0; padding:0 ">            // variable jump to abstract cmd, program_buffer or resume</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            if (resumereq_wdata_aligned[wdata_hartsel]) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              rdata_d = {32'b0, dm::jal('0, 21'(dm::ResumeAddress[11:0])-21'(WhereToAddr))};</pre>
<pre style="margin:0; padding:0 ">            end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">            // there is a command active so jump there</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            if (cmdbusy_o) begin</pre>
<pre style="margin:0; padding:0 ">              // transfer not set is shortcut to the program buffer if postexec is set</pre>
<pre style="margin:0; padding:0 ">              // keep this statement narrow to not catch invalid commands</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              if (cmd_i.cmdtype == dm::AccessRegister &&</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                  !ac_ar.transfer && ac_ar.postexec) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                rdata_d = {32'b0, dm::jal('0, 21'(ProgBufBaseAddr)-21'(WhereToAddr))};</pre>
<pre style="margin:0; padding:0 ">              // this is a legit abstract cmd -> execute it</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                rdata_d = {32'b0, dm::jal('0, 21'(AbstractCmdBaseAddr)-21'(WhereToAddr))};</pre>
<pre style="margin:0; padding:0 ">              end</pre>
<pre style="margin:0; padding:0 ">            end</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          [DataBaseAddr:DataEndAddr]: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            rdata_d = {</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                      data_i[$clog2(dm::ProgBufSize)'(addr_i[DbgAddressBits-1:3] -</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                          DataBaseAddr[DbgAddressBits-1:3] + 1'b1)],</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                      data_i[$clog2(dm::ProgBufSize)'(addr_i[DbgAddressBits-1:3] -</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                          DataBaseAddr[DbgAddressBits-1:3])]</pre>
<pre style="margin:0; padding:0 ">                      };</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          [ProgBufBaseAddr:ProgBufEndAddr]: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            rdata_d = progbuf[$clog2(dm::ProgBufSize)'(addr_i[DbgAddressBits-1:3] -</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                          ProgBufBaseAddr[DbgAddressBits-1:3])];</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">          // two slots for abstract command</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          [AbstractCmdBaseAddr:AbstractCmdEndAddr]: begin</pre>
<pre style="margin:0; padding:0 ">            // return the correct address index</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            rdata_d = abstract_cmd[3'(addr_i[DbgAddressBits-1:3] -</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                           AbstractCmdBaseAddr[DbgAddressBits-1:3])];</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="margin:0; padding:0 ">          // harts are polling for flags here</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          [FlagsBaseAddr:FlagsEndAddr]: begin</pre>
<pre style="margin:0; padding:0 ">            // release the corresponding hart</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            if (({addr_i[DbgAddressBits-1:3], 3'b0} - FlagsBaseAddr[DbgAddressBits-1:0]) ==</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              (DbgAddressBits'(hartsel) & {{(DbgAddressBits-3){1'b1}}, 3'b0})) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              rdata[DbgAddressBits'(hartsel) & DbgAddressBits'(3'b111)] = {6'b0, resume, go};</pre>
<pre style="margin:0; padding:0 ">            end</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            rdata_d = rdata;</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          default: ;</pre>
<pre style="margin:0; padding:0 ">        endcase</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    data_o = data_bits;</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  always_comb begin : p_abstract_cmd_rom</pre>
<pre style="margin:0; padding:0 ">    // this abstract command is currently unsupported</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    unsupported_command = 1'b0;</pre>
<pre style="margin:0; padding:0 ">    // default memory</pre>
<pre style="margin:0; padding:0 ">    // if ac_ar.transfer is not set then we can take a shortcut to the program buffer</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[0][31:0]  = dm::illegal();</pre>
<pre style="margin:0; padding:0 ">    // load debug module base address into a0, this is shared among all commands</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[0][63:32] = dm::auipc(5'd10, '0);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[1][31:0]  = dm::srli(5'd10, 5'd10, 6'd12); // clr lowest 12b -> DM base offset</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[1][63:32] = dm::slli(5'd10, 5'd10, 6'd12);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[2][31:0]  = dm::nop();</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[2][63:32] = dm::nop();</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[3][31:0]  = dm::nop();</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[3][63:32] = dm::nop();</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[4][31:0]  = dm::csrr(dm::CSR_DSCRATCH1, 5'd10);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[4][63:32] = dm::ebreak();</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    abstract_cmd[7:5]      = '0;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    // this depends on the command being executed</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    unique case (cmd_i.cmdtype)</pre>
<pre style="margin:0; padding:0 ">      // --------------------</pre>
<pre style="margin:0; padding:0 ">      // Access Register</pre>
<pre style="margin:0; padding:0 ">      // --------------------</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      dm::AccessRegister: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (32'(ac_ar.aarsize) < MaxAar && ac_ar.transfer && ac_ar.write) begin</pre>
<pre style="margin:0; padding:0 ">          // store a0 in dscratch1</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          abstract_cmd[0][31:0] = dm::csrw(dm::CSR_DSCRATCH1, 5'd10);</pre>
<pre style="margin:0; padding:0 ">          // this range is reserved</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          if (ac_ar.regno[15:14] != '0) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[0][31:0] = dm::ebreak(); // we leave asap</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            unsupported_command = 1'b1;</pre>
<pre style="margin:0; padding:0 ">          // A0 access needs to be handled separately, as we use A0 to load</pre>
<pre style="margin:0; padding:0 ">          // the DM address offset need to access DSCRATCH1 in this case</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          end else if (ac_ar.regno[12] && (!ac_ar.regno[5]) &&</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                      (ac_ar.regno[4:0] == 5'd10)) begin</pre>
<pre style="margin:0; padding:0 ">            // store s0 in dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // load from data register</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][63:32] = dm::load(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre style="margin:0; padding:0 ">            // and store it in the corresponding CSR</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][31:0]  = dm::csrw(dm::CSR_DSCRATCH1, 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // restore s0 again from dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">          // GPR/FPR access</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          end else if (ac_ar.regno[12]) begin</pre>
<pre style="margin:0; padding:0 ">            // determine whether we want to access the floating point register or not</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            if (ac_ar.regno[5]) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              abstract_cmd[2][31:0] =</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                  dm::float_load(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              abstract_cmd[2][31:0] =</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                  dm::load(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre style="margin:0; padding:0 ">            end</pre>
<pre style="margin:0; padding:0 ">          // CSR access</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          end else begin</pre>
<pre style="margin:0; padding:0 ">            // data register to CSR</pre>
<pre style="margin:0; padding:0 ">            // store s0 in dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // load from data register</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][63:32] = dm::load(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre style="margin:0; padding:0 ">            // and store it in the corresponding CSR</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][31:0]  = dm::csrw(dm::csr_reg_t'(ac_ar.regno[11:0]), 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // restore s0 again from dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        end else if (32'(ac_ar.aarsize) < MaxAar && ac_ar.transfer && !ac_ar.write) begin</pre>
<pre style="margin:0; padding:0 ">          // store a0 in dscratch1</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          abstract_cmd[0][31:0]  = dm::csrw(dm::CSR_DSCRATCH1, 5'd10);</pre>
<pre style="margin:0; padding:0 ">          // this range is reserved</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          if (ac_ar.regno[15:14] != '0) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              abstract_cmd[0][31:0] = dm::ebreak(); // we leave asap</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              unsupported_command = 1'b1;</pre>
<pre style="margin:0; padding:0 ">          // A0 access needs to be handled separately, as we use A0 to load</pre>
<pre style="margin:0; padding:0 ">          // the DM address offset need to access DSCRATCH1 in this case</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          end else if (ac_ar.regno[12] && (!ac_ar.regno[5]) &&</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                      (ac_ar.regno[4:0] == 5'd10)) begin</pre>
<pre style="margin:0; padding:0 ">            // store s0 in dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // read value from CSR into s0</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][63:32] = dm::csrr(dm::CSR_DSCRATCH1, 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // and store s0 into data section</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][31:0]  = dm::store(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre style="margin:0; padding:0 ">            // restore s0 again from dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">          // GPR/FPR access</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          end else if (ac_ar.regno[12]) begin</pre>
<pre style="margin:0; padding:0 ">            // determine whether we want to access the floating point register or not</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            if (ac_ar.regno[5]) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              abstract_cmd[2][31:0] =</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                  dm::float_store(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">              abstract_cmd[2][31:0] =</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                  dm::store(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre style="margin:0; padding:0 ">            end</pre>
<pre style="margin:0; padding:0 ">          // CSR access</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          end else begin</pre>
<pre style="margin:0; padding:0 ">            // CSR register to data</pre>
<pre style="margin:0; padding:0 ">            // store s0 in dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // read value from CSR into s0</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[2][63:32] = dm::csrr(dm::csr_reg_t'(ac_ar.regno[11:0]), 5'd8);</pre>
<pre style="margin:0; padding:0 ">            // and store s0 into data section</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][31:0]  = dm::store(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre style="margin:0; padding:0 ">            // restore s0 again from dscratch</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre style="margin:0; padding:0 ">          end</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        end else if (32'(ac_ar.aarsize) >= MaxAar || ac_ar.aarpostincrement == 1'b1) begin</pre>
<pre style="margin:0; padding:0 ">          // this should happend when e.g. ac_ar.aarsize >= MaxAar</pre>
<pre style="margin:0; padding:0 ">          // Openocd will try to do an access with aarsize=64 bits</pre>
<pre style="margin:0; padding:0 ">          // first before falling back to 32 bits.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          abstract_cmd[0][31:0] = dm::ebreak(); // we leave asap</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          unsupported_command = 1'b1;</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">        // Check whether we need to execute the program buffer. When we</pre>
<pre style="margin:0; padding:0 ">        // get an unsupported command we really should abort instead of</pre>
<pre style="margin:0; padding:0 ">        // still trying to execute the program buffer, makes it easier</pre>
<pre style="margin:0; padding:0 ">        // for the debugger to recover</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (ac_ar.postexec && !unsupported_command) begin</pre>
<pre style="margin:0; padding:0 ">          // issue a nop, we will automatically run into the program buffer</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          abstract_cmd[4][63:32] = dm::nop();</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 ">      // not supported at the moment</pre>
<pre style="margin:0; padding:0 ">      // dm::QuickAccess:;</pre>
<pre style="margin:0; padding:0 ">      // dm::AccessMemory:;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      default: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        abstract_cmd[0][31:0] = dm::ebreak();</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        unsupported_command = 1'b1;</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 ">    endcase</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [63:0] rom_addr;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign rom_addr = 64'(addr_i);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  debug_rom i_debug_rom (</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    .clk_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    .req_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    .addr_i  ( rom_addr  ),</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    .rdata_o ( rom_rdata )</pre>
<pre style="margin:0; padding:0 ">  );</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // ROM starts at the HaltAddress of the core e.g.: it immediately jumps to</pre>
<pre style="margin:0; padding:0 ">  // the ROM base address</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign fwd_rom_d = logic'(addr_i[DbgAddressBits-1:0] >= dm::HaltAddress[DbgAddressBits-1:0]);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      fwd_rom_q       <= 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      rdata_q         <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      state_q         <= Idle;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      word_enable32_q <= 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      fwd_rom_q       <= fwd_rom_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      rdata_q         <= rdata_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      state_q         <= state_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      word_enable32_q <= addr_i[2];</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      halted_q   <= 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      resuming_q <= 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      halted_q   <= SelectableHarts & halted_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      resuming_q <= SelectableHarts & resuming_d;</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre id="id497" style="background-color: #FFB6C1; margin:0; padding:0 ">endmodule : dm_mem</pre>
<pre style="margin:0; padding:0 "></pre>
</body>
</html>
