
<!DOCTYPE html>
<html>
<head>
<style>
body {

}
p {
font-size: 14px;
}</style>
<h3>../src/lowrisc_ip_rv_plic_component_0.1/rtl/rv_plic_target.sv Cov: 81% </h3>
<pre style="margin:0; padding:0 ">// Copyright lowRISC contributors.</pre>
<pre style="margin:0; padding:0 ">// Licensed under the Apache License, Version 2.0, see LICENSE for details.</pre>
<pre style="margin:0; padding:0 ">// SPDX-License-Identifier: Apache-2.0</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// RISC-V Platform-Level Interrupt Generator for Target</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// This module basically doing IE & IP based on priority and threshold.</pre>
<pre style="margin:0; padding:0 ">// Keep in mind that increasing MAX_PRIO affects logic size a lot.</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// The module implements a binary tree to find the maximal entry. the solution</pre>
<pre style="margin:0; padding:0 ">// has O(N) area and O(log(N)) delay complexity, and thus scales well with</pre>
<pre style="margin:0; padding:0 ">// many input sources.</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">`include "prim_assert.sv"</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">module rv_plic_target #(</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  parameter int N_SOURCE = 32,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  parameter int MAX_PRIO = 7,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // Local param (Do not change this through parameter</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int SrcWidth  = $clog2(N_SOURCE+1),  // derived parameter</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int PrioWidth = $clog2(MAX_PRIO+1)   // derived parameter</pre>
<pre style="margin:0; padding:0 ">) (</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input clk_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input rst_ni,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input [N_SOURCE-1:0]  ip,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input [N_SOURCE-1:0]  ie,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input [PrioWidth-1:0] prio [N_SOURCE],</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input [PrioWidth-1:0] threshold,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic            irq,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [SrcWidth-1:0] irq_id</pre>
<pre style="margin:0; padding:0 ">);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre id="id38" style="background-color: #FFB6C1; margin:0; padding:0 ">  // this only works with 2 or more sources</pre>
<pre style="margin:0; padding:0 ">  `ASSERT_INIT(NumSources_A, N_SOURCE >= 2)</pre>
<pre style="margin:0; padding:0 "></pre>
<pre id="id41" style="background-color: #FFB6C1; margin:0; padding:0 ">  // align to powers of 2 for simplicity</pre>
<pre style="margin:0; padding:0 ">  // a full binary tree with N levels has 2**N + 2**N-1 nodes</pre>
<pre style="margin:0; padding:0 ">  localparam int NumLevels = $clog2(N_SOURCE);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [2**(NumLevels+1)-2:0]            is_tree;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [2**(NumLevels+1)-2:0][SrcWidth-1:0]  id_tree;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [2**(NumLevels+1)-2:0][PrioWidth-1:0] max_tree;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  for (genvar level = 0; level < NumLevels+1; level++) begin : gen_tree</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 ">    // level+1   C0   C1   <- "Base1" points to the first node on "level+1",</pre>
<pre style="margin:0; padding:0 ">    //            \  /         these nodes are the children of the nodes one level below</pre>
<pre style="margin:0; padding:0 ">    // level       Pa      <- "Base0", points to the first node on "level",</pre>
<pre style="margin:0; padding:0 ">    //                         these nodes are the parents of the nodes one level above</pre>
<pre style="margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 ">    // hence we have the following indices for the paPa, C0, C1 nodes:</pre>
<pre style="margin:0; padding:0 ">    // Pa = 2**level     - 1 + offset       = Base0 + offset</pre>
<pre style="margin:0; padding:0 ">    // C0 = 2**(level+1) - 1 + 2*offset     = Base1 + 2*offset</pre>
<pre style="margin:0; padding:0 ">    // C1 = 2**(level+1) - 1 + 2*offset + 1 = Base1 + 2*offset + 1</pre>
<pre style="margin:0; padding:0 ">    //</pre>
<pre style="margin:0; padding:0 ">    localparam int Base0 = (2**level)-1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    localparam int Base1 = (2**(level+1))-1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      localparam int Pa = Base0 + offset;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      localparam int C0 = Base1 + 2*offset;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      localparam int C1 = Base1 + 2*offset + 1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "></pre>
<pre id="id68" style="background-color: #FFB6C1; margin:0; padding:0 ">      // this assigns the gated interrupt source signals, their</pre>
<pre id="id69" style="background-color: #FFB6C1; margin:0; padding:0 ">      // corresponding IDs and priorities to the tree leafs</pre>
<pre style="margin:0; padding:0 ">      if (level == NumLevels) begin : gen_leafs</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (offset < N_SOURCE) begin : gen_assign</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          assign is_tree[Pa]  = ip[offset] & ie[offset];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          assign id_tree[Pa]  = offset;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          assign max_tree[Pa] = prio[offset];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        end else begin : gen_tie_off</pre>
<pre id="id76" style="background-color: #FFB6C1; margin:0; padding:0 ">          assign is_tree[Pa]  = '0;</pre>
<pre id="id77" style="background-color: #FFB6C1; margin:0; padding:0 ">          assign id_tree[Pa]  = '0;</pre>
<pre id="id78" style="background-color: #FFB6C1; margin:0; padding:0 ">          assign max_tree[Pa] = '0;</pre>
<pre id="id79" style="background-color: #FFB6C1; margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">      // this creates the node assignments</pre>
<pre style="margin:0; padding:0 ">      end else begin : gen_nodes</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        // NOTE: the code below has been written in this way in order to work</pre>
<pre style="margin:0; padding:0 ">        // around a synthesis issue in Vivado 2018.3 and 2019.2 where the whole</pre>
<pre style="margin:0; padding:0 ">        // module would be optimized away if these assign statements contained</pre>
<pre style="margin:0; padding:0 ">        // ternary statements to implement the muxes.</pre>
<pre style="margin:0; padding:0 ">        //</pre>
<pre style="margin:0; padding:0 ">        // TODO: rewrite these lines with ternary statmements onec the problem</pre>
<pre style="margin:0; padding:0 ">        // has been fixed in the tool.</pre>
<pre style="margin:0; padding:0 ">        //</pre>
<pre style="margin:0; padding:0 ">        // See also originating issue:</pre>
<pre style="margin:0; padding:0 ">        // https://github.com/lowRISC/opentitan/issues/1355</pre>
<pre style="margin:0; padding:0 ">        // Xilinx issue:</pre>
<pre style="margin:0; padding:0 ">        // https://forums.xilinx.com/t5/Synthesis/Simulation-Synthesis-Mismatch-with-Vivado-2018-3/m-p/1065923#M33849</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">        logic sel; // local helper variable</pre>
<pre id="id96" style="background-color: #FFB6C1; margin:0; padding:0 ">        // in case only one of the parent has a pending irq, forward that one</pre>
<pre style="margin:0; padding:0 ">        // in case both irqs are pending, forward the one with higher priority</pre>
<pre style="margin:0; padding:0 ">        assign sel = (~is_tree[C0] & is_tree[C1]) |</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                     (is_tree[C0] & is_tree[C1] & logic'(max_tree[C1] > max_tree[C0]));</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        // forwarding muxes</pre>
<pre style="margin:0; padding:0 ">        assign is_tree[Pa]  = (sel              & is_tree[C1])  | ((~sel)            & is_tree[C0]);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        assign id_tree[Pa]  = ({SrcWidth{sel}}  & id_tree[C1])  | ({SrcWidth{~sel}}  & id_tree[C0]);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        assign max_tree[Pa] = ({PrioWidth{sel}} & max_tree[C1]) | ({PrioWidth{~sel}} & max_tree[C0]);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 ">    end : gen_level</pre>
<pre id="id106" style="background-color: #FFB6C1; margin:0; padding:0 ">  end : gen_tree</pre>
<pre id="id107" style="background-color: #FFB6C1; margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  logic irq_d, irq_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [SrcWidth-1:0] irq_id_d, irq_id_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // the results can be found at the tree root</pre>
<pre style="margin:0; padding:0 ">  assign irq_d    = (max_tree[0] > threshold) ? is_tree[0] : 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign irq_id_d = (is_tree[0]) ? id_tree[0] : '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  always_ff @(posedge clk_i or negedge rst_ni) begin : gen_regs</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      irq_q    <= 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      irq_id_q <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      irq_q    <= irq_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      irq_id_q <= irq_id_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  assign irq    = irq_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign irq_id = irq_id_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">endmodule</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 "></pre>
</body>
</html>
