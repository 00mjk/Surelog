
<!DOCTYPE html>
<html>
<head>
<style>
body {

}
p {
font-size: 14px;
}</style>
<h3>../src/lowrisc_tlul_adapter_host_0.1/rtl/tlul_adapter_host.sv Cov: 95% </h3>
<pre style="margin:0; padding:0 ">// Copyright lowRISC contributors.</pre>
<pre style="margin:0; padding:0 ">// Licensed under the Apache License, Version 2.0, see LICENSE for details.</pre>
<pre style="margin:0; padding:0 ">// SPDX-License-Identifier: Apache-2.0</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// tlul_adapter (Host adapter) converts basic req/grant/rvalid into TL-UL interface. If</pre>
<pre style="margin:0; padding:0 ">// MAX_REQS == 1 it is purely combinational logic. If MAX_REQS > 1 flops are required.</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// The host driving the adapter is responsible for ensuring it doesn't have more requests in flight</pre>
<pre style="margin:0; padding:0 ">// than the specified MAX_REQS.</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// The outgoing address is always word aligned. The access size is always the word size (as</pre>
<pre style="margin:0; padding:0 ">// specified by TL_DW). For write accesses that occupy all lanes the operation is PutFullData,</pre>
<pre style="margin:0; padding:0 ">// otherwise it is PutPartialData, mask is generated from be_i. For reads all lanes are enabled as</pre>
<pre style="margin:0; padding:0 ">// required by TL-UL (every bit in mask set).</pre>
<pre style="margin:0; padding:0 ">//</pre>
<pre style="margin:0; padding:0 ">// When MAX_REQS > 1 tlul_adapter_host does not do anything to order responses from the TL-UL</pre>
<pre style="margin:0; padding:0 ">// interface which could return them out of order. It is the host's responsibility to either only</pre>
<pre style="margin:0; padding:0 ">// have outstanding requests to an address space it knows will return responses in order or to not</pre>
<pre style="margin:0; padding:0 ">// care about out of order responses (note that if read data is returned out of order there is no</pre>
<pre style="margin:0; padding:0 ">// way to determine this).</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">`include "prim_assert.sv"</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">module tlul_adapter_host #(</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  parameter int unsigned MAX_REQS = 2</pre>
<pre style="margin:0; padding:0 ">) (</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input clk_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input rst_ni,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input                              req_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic                       gnt_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [top_pkg::TL_AW-1:0]  addr_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic                       we_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [top_pkg::TL_DW-1:0]  wdata_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  logic [top_pkg::TL_DBW-1:0] be_i,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic                       valid_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic [top_pkg::TL_DW-1:0]  rdata_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output logic                       err_o,</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  output tlul_pkg::tl_h2d_t          tl_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  input  tlul_pkg::tl_d2h_t          tl_i</pre>
<pre style="margin:0; padding:0 ">);</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int WordSize = $clog2(top_pkg::TL_DBW);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [top_pkg::TL_AIW-1:0] tl_source;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [top_pkg::TL_DBW-1:0] tl_be;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  if (MAX_REQS == 1) begin : g_single_req</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    assign tl_source = '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  end else begin : g_multiple_reqs</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    localparam int ReqNumW  = $clog2(MAX_REQS);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre id="id54" style="background-color: #FFB6C1; margin:0; padding:0 ">    logic [ReqNumW-1:0] source_d;</pre>
<pre id="id55" style="background-color: #FFB6C1; margin:0; padding:0 ">    logic [ReqNumW-1:0] source_q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        source_q <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        source_q <= source_d;</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      source_d = source_q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      if (req_i && gnt_o) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        if (source_q == MAX_REQS - 1) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          source_d = '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">        end else  begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">          source_d = source_q + 1;</pre>
<pre style="margin:0; padding:0 ">        end</pre>
<pre style="margin:0; padding:0 ">      end</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    assign tl_source = top_pkg::TL_AIW'(source_q);</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  // For TL-UL Get opcode all active bytes must have their mask bit set, so all reads get all tl_be</pre>
<pre style="margin:0; padding:0 ">  // bits set. For writes the supplied be_i is used as the mask.</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign tl_be = ~we_i ? {top_pkg::TL_DBW{1'b1}} : be_i;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign tl_o = '{</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_valid:   req_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_opcode:  (~we_i) ? tlul_pkg::Get           :</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">               (&be_i) ? tlul_pkg::PutFullData   :</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">                         tlul_pkg::PutPartialData,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_param:   3'h0,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_size:    top_pkg::TL_SZW'(WordSize),</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_mask:    tl_be,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_source:  tl_source,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_address: {addr_i[31:WordSize], {WordSize{1'b0}}},</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_data:    wdata_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    a_user:    '{default:'0},</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">    d_ready:   1'b1</pre>
<pre style="margin:0; padding:0 ">  };</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign gnt_o   = tl_i.a_ready;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign valid_o = tl_i.d_valid;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign rdata_o = tl_i.d_data;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  assign err_o   = tl_i.d_error;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">`ifdef INC_ASSERT</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  localparam int OutstandingReqCntW =</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    (MAX_REQS == 2 ** $clog2(MAX_REQS)) ? $clog2(MAX_REQS) + 1 : $clog2(MAX_REQS);</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [OutstandingReqCntW-1:0] outstanding_reqs_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  logic [OutstandingReqCntW-1:0] outstanding_reqs_d;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    outstanding_reqs_d = outstanding_reqs_q;</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if ((req_i && gnt_o) && !valid_o) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      outstanding_reqs_d = outstanding_reqs_q + 1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    end else if (!(req_i && gnt_o) && valid_o) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      outstanding_reqs_d = outstanding_reqs_q - 1;</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      outstanding_reqs_q <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">    end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">      outstanding_reqs_q <= outstanding_reqs_d;</pre>
<pre style="margin:0; padding:0 ">    end</pre>
<pre style="margin:0; padding:0 ">  end</pre>
<pre style="margin:0; padding:0 "></pre>
<pre style="margin:0; padding:0 ">  `ASSERT(DontExceeedMaxReqs, req_i |-> outstanding_reqs_d <= MAX_REQS);</pre>
<pre id="id132" style="background-color: #FFB6C1; margin:0; padding:0 ">`endif</pre>
<pre style="margin:0; padding:0 ">endmodule</pre>
<pre style="margin:0; padding:0 "></pre>
</body>
</html>
